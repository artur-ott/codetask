import org.specs2.mutable._

import play.api.test._
import play.api.test.Helpers._
import play.api.libs.json._
import models.tasks._
import models.tasks.Tasks._
import org.apache.commons.codec.binary.Base64
import org.specs2.runner._
import org.junit.runner._

@RunWith(classOf[JUnitRunner])
class RestSpec extends Specification {
  def encodeBase64(s: String) = new String(Base64.encodeBase64(s.getBytes))
  val auth = "Basic " + encodeBase64("admin@a.pp:$1amn_$2pwrt")
  var courseId = ""
  var userId = ""
  val loop = 500


  "Application Course API" should {
    "create Course" in new WithApplication {
      //val json: JsValue = Json.parse("""{"id": 0, "title": "Neuer Kurs 5","chapters": [{"id": 1,"title": "About Scala Lists","tasks": [{"id": "video1","tag": "video-task","data": {"description": "In diesem Kapitel sollend Listen in Scala näher erläutert werden\n Listen sind collections und können objekte speichern\n Listen sind prinzipiell immutable also unveränderbar\n Im folgenden Video werden Listen ausfürlich erläutert","url": "U23j6yH21W4"},"solution": "watched"},{"id": "koan1","tag": "koan-task","data": {"description": "Mit der Funktion <b>contains</b> kann geprüft werden ob eine Liste ein bestimmtes Element enthält.\n Mit der Funktion <b>map</b> können funktionen auf listen angewendet werden, die Ergebnisse werden in einer neuen Liste gespeichert.\n Versuch in dem folgenden <b>Koan</b> die richtigen Werte einzutragen","code": "val l = List(1, 2, 3, 4)\nval l2 = l.map { x => x + 1 }\nval l3 = l.map { x => x * x }\n\nl should be (__)\nl2 should be(__)\nl3 shouldBe __", "mode":"scala", "solutions": ["List(1, 2, 3, 4)","List(2, 3, 4, 5)","List(1, 4, 9, 16)"]},"solution": "List(1, 2, 3, 4),List(2, 3, 4, 5),List(1, 4, 9, 16)"},{"id": "koan2","tag": "koan-task","data": {"description": "Zu Listen können auch Werte hinzugefügt werden.<br>Dies kann mit <b>++</b> geschehen.","code": "val x = 1\nval y = 300\n//some\n//lonely\n//comment\n//to\n//add\n//lines\nval l = List(1, 3, 5)\nval l2 = l ++ List(6)\n    \nl2 shouldBe __", "mode":"scala", "solutions": ["List(1, 3, 5, 6)"]},"solution": "List(1, 3, 5, 6)"},{"id": "code1","tag": "code-task","data": {"description": "schreiben sie eine function reverse die eine umgekehrte liste zurück geben.\n Nutzen Sie nicht die bereits vorhandenen Möglichkeit\n <b>List.reverse</b>", "mode":"scala", "code": "def rvrs(l: List[Any]): List[Any] = {\n  //solve\n}"},"solution": "rvrs(List(1, 2, 3)) should be(List(3, 2, 1))"},{"id": "koan3","tag": "koan-task","data": {"description": "Java Koan", "mode":"java","code": "@RunWith(KoanRunner.class)\n  public class MyKoans {\n\t@Koan\n\tpublic void test() {\n\t\tint i= 10;\n\t\tint j = 5;\n\t\tint product = i * j;\n\n\t\tassertThat(product, is(__)\n\t}\n}","solutions": ["50"]},"solution": "50"}]}]}""")
      //val json: JsValue = Json.parse("""{"id": 0, "title": "Neuer Kurs 5","chapters": [{"id": 1, "title": "About Mutable Sets", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Mutable sets can be created easily","code":"val mySet = mutable.Set(\"Michigan\", \"Ohio\", \"Wisconsin\", \"Iowa\")\nmySet.size should be(__)\nmySet += \"Oregon\"\nmySet contains \"Oregon\" should be(__)","mode":"scala","solutions":["4","true"]},"solution":"4,true"},{"id":"koan2","tag":"koan-task","data":{"description":"Mutable sets can have elements removed","code":"val mySet = mutable.Set(\"Michigan\", \"Ohio\", \"Wisconsin\", \"Iowa\")\nmySet -= \"Ohio\"\nmySet contains \"Ohio\" should be(__)","mode":"scala","solutions":["false"]},"solution":"false"},{"id":"koan3","tag":"koan-task","data":{"description":"Mutable sets can have tuples of elements removed","code":"val mySet = mutable.Set(\"Michigan\", \"Ohio\", \"Wisconsin\", \"Iowa\")\nmySet -= (\"Iowa\", \"Ohio\")\nmySet contains \"Ohio\" should be(__)\nmySet.size should be(__)","mode":"scala","solutions":["false","2"]},"solution":"false,2"},{"id":"koan4","tag":"koan-task","data":{"description":"Mutable sets can have tuples of elements added","code":"val mySet = mutable.Set(\"Michigan\", \"Wisconsin\")\nmySet += (\"Iowa\", \"Ohio\")\nmySet contains \"Ohio\" should be(__)\nmySet.size should be(__)","mode":"scala","solutions":["true","4"]},"solution":"true,4"},{"id":"koan5","tag":"koan-task","data":{"description":"Mutable sets can have Lists of elements added","code":"val mySet = mutable.Set(\"Michigan\", \"Wisconsin\")\nmySet ++= List(\"Iowa\", \"Ohio\")\nmySet contains \"Ohio\" should be(__)\nmySet.size should be(__)","mode":"scala","solutions":["true","4"]},"solution":"true,4"},{"id":"koan6","tag":"koan-task","data":{"description":"Mutable sets can have Lists of elements removed","code":"val mySet = mutable.Set(\"Michigan\", \"Ohio\", \"Wisconsin\", \"Iowa\")\nmySet --= List(\"Iowa\", \"Ohio\")\nmySet contains \"Ohio\" should be(__)\nmySet.size should be(__)","mode":"scala","solutions":["false","2"]},"solution":"false,2"},{"id":"koan7","tag":"koan-task","data":{"description":"Mutable sets can be cleared","code":"val mySet = mutable.Set(\"Michigan\", \"Ohio\", \"Wisconsin\", \"Iowa\")\nmySet.clear() // Convention is to use parens if possible when method called changes state\nmySet contains \"Ohio\" should be(__)\nmySet.size should be(__)","mode":"scala","solutions":["false","0"]},"solution":"false,0"}]},{"id": 2, "title": "About Literal Booleans", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Boolean literals are either true or false, using the true or false keyword","code":"val a = true\nval b = false\nval c = 1 > 2\nval d = 1 < 2\nval e = a == c\nval f = b == d\na should be(__)\nb should be(__)\nc should be(__)\nd should be(__)\ne should be(__)\nf should be(__)","mode":"scala","solutions":["true","false","false","true","false","false"]},"solution":"true,false,false,true,false,false"}]},{"id": 3, "title": "About Options", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Option can have one of two values - Some or None","code":"val someValue: Option[String] = Some(\"I am wrapped in something\")\nsomeValue.get should be(__)\n\nval nullValue: Option[String] = None\nnullValue should be(__)","mode":"scala","solutions":["\"I am wrapped in something\"","None"]},"solution":"\"I am wrapped in something\",None"},{"id":"koan2","tag":"koan-task","data":{"description":"Represent null with None because null is a bad idea","code":"val value1 = maybeItWillReturnSomething(true)\nval value2 = maybeItWillReturnSomething(false)\n\nvalue1.get should be(__)\nintercept[java.util.NoSuchElementException] {\n  value2.get\n}","mode":"scala","solutions":["\"Found value\""]},"solution":"\"Found value\""},{"id":"koan3","tag":"koan-task","data":{"description":"Provide a default value for None","code":"val value1 = maybeItWillReturnSomething(true)\nval value2 = maybeItWillReturnSomething(false)\n\nvalue1 getOrElse \"No value\" should be(__)\nvalue2 getOrElse \"No value\" should be(__)\nvalue2 getOrElse {\n  \"default function\"\n} should be(__)","mode":"scala","solutions":["\"Found value\"","\"No value\"","\"default function\""]},"solution":"\"Found value\",\"No value\",\"default function\""},{"id":"koan4","tag":"koan-task","data":{"description":"checking whether option has value","code":"val value1 = maybeItWillReturnSomething(true)\nval value2 = maybeItWillReturnSomething(false)\n\nvalue1.isEmpty should be(__)\nvalue2.isEmpty should be(__)","mode":"scala","solutions":["false","true"]},"solution":"false,true"},{"id":"koan5","tag":"koan-task","data":{"description":"Option can also be used with pattern matching","code":"val someValue: Option[Double] = Some(20.0)\nval value = someValue match {\n  case Some(v) => v\n  case None => 0.0\n}\nvalue should be(__)\nval noValue: Option[Double] = None\nval value1 = noValue match {\n  case Some(v) => v\n  case None => 0.0\n}\nvalue1 should be(__)","mode":"scala","solutions":["20.0","0.0"]},"solution":"20.0,0.0"},{"id":"koan6","tag":"koan-task","data":{"description":"Option is more than just a replacement of null, its also a collection","code":"Some(10) map { _ + 10} should be(__)\nSome(10) filter { _ == 10} should be(__)\nSome(Some(10)) flatMap { _ map { _ + 10}} should be(__)\n\nvar newValue1 = 0\nSome(20) foreach { newValue1 = _}\nnewValue1 should be(__)\n\nvar newValue2 = 0\nNone foreach { newValue2 = _}\nnewValue2 should be(__)","mode":"scala","solutions":["Some(20)","Some(10)","Some(20)","20","0"]},"solution":"Some(20),Some(10),Some(20),20,0"},{"id":"koan7","tag":"koan-task","data":{"description":"Using Option to avoid if checks for null","code":"//the ugly version\ndef makeFullName(firstName: String, lastName: String) = {\n  if (firstName != null) {\n    if (lastName != null) {\n      firstName + \" \" + lastName\n    } else {\n      null\n    }\n  } else {\n    null\n  }\n}\nmakeFullName(\"Nilanjan\", \"Raychaudhuri\") should be(__)\nmakeFullName(\"Nilanjan\", null) should be(__)\n\n//the pretty version\ndef makeFullNamePrettyVersion(firstName: Option[String], lastName: Option[String]) = {\n  firstName flatMap {\n    fname =>\n      lastName flatMap {\n        lname =>\n          Some(fname + \" \" + lname)\n      }\n  }\n}\nmakeFullNamePrettyVersion(Some(\"Nilanjan\"), Some(\"Raychaudhuri\")) should be(__)\nmakeFullNamePrettyVersion(Some(\"Nilanjan\"), None) should be(__)","mode":"scala","solutions":["\"Nilanjan Raychaudhuri\"","null","Some(\"Nilanjan Raychaudhuri\")","None"]},"solution":"\"Nilanjan Raychaudhuri\",null,Some(\"Nilanjan Raychaudhuri\"),None"},{"id":"koan8","tag":"koan-task","data":{"description":"Using in for comprehension","code":"val values = List(Some(10), Some(20), None, Some(15))\nval newValues = for {\n  someValue <- values\n  value <- someValue\n} yield value\nnewValues should be(__)","mode":"scala","solutions":["List(10, 20, 15)"]},"solution":"List(10, 20, 15)"}]},{"id": 4, "title": "About Traits", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"A class uses the extends keyword to mixin a trait if it is the only relationship the class inherits","code":"case class Event(name: String)\n\ntrait EventListener {\n  def listen(event: Event): String\n}\n\nclass MyListener extends EventListener {\n  def listen(event: Event): String = {\n    event match {\n      case Event(\"Moose Stampede\") => \"An unfortunate moose stampede occurred\"\n      case _ => \"Nothing of importance occurred\"\n    }\n  }\n}\n\nval evt = Event(\"Moose Stampede\")\nval myListener = new MyListener\nmyListener.listen(evt) should be (__)","mode":"scala","solutions":["\"An unfortunate moose stampede occurred\""]},"solution":"\"An unfortunate moose stampede occurred\""},{"id":"koan2","tag":"koan-task","data":{"description":"A class can only \\'extend\\' from one class or trait, any subsequent extension should use the keyword \\'with\\'","code":"case class Event(name: String)\n\ntrait EventListener {\n  def listen(event: Event): String\n}\n\nclass OurListener\n\nclass MyListener extends OurListener with EventListener {\n  def listen(event: Event) : String = {\n    event match {\n      case Event(\"Woodchuck Stampede\") => \"An unfortunate woodchuck stampede occurred\"\n      case _ => \"Nothing of importance occurred\"\n    }\n  }\n}\n\nval evt = Event(\"Woodchuck Stampede\")\nval myListener = new MyListener\nmyListener.listen(evt) should be (__)","mode":"scala","solutions":["\"An unfortunate woodchuck stampede occurred\""]},"solution":"\"An unfortunate woodchuck stampede occurred\""},{"id":"koan3","tag":"koan-task","data":{"description":"Traits are polymorphic. Any type can be referred to by another type if related by extension","code":"case class Event(name: String)\n\ntrait EventListener {\n  def listen(event: Event): String\n}\n\nclass MyListener extends EventListener {\n  def listen(event: Event) : String = {\n    event match {\n      case Event(\"Moose Stampede\") => \"An unfortunate moose stampede occurred\"\n      case _ => \"Nothing of importance occurred\"\n    }\n  }\n}\n\nval myListener = new MyListener\n\nmyListener.isInstanceOf[MyListener] should be(__)\nmyListener.isInstanceOf[EventListener] should be(__)\nmyListener.isInstanceOf[Any] should be(__)\nmyListener.isInstanceOf[AnyRef] should be(__)","mode":"scala","solutions":["true","true","true","true"]},"solution":"true,true,true,true"},{"id":"koan4","tag":"koan-task","data":{"description":"Traits can have concrete implementations that can be mixed into concrete classes with it's own state","code":"trait Logging {\n  var logCache = List[String]()\n\n  def log(value: String) = {\n    logCache = logCache :+ value\n    println(value)\n  }\n}\n\nclass Welder extends Logging {\n  def weld() {\n    log(\"welding pipe\")\n  }\n}\n\nclass Baker extends Logging {\n  def bake() {\n    log(\"baking cake\")\n  }\n}\n\nval welder = new Welder\nwelder.weld()\n\n\nval baker = new Baker\nbaker.bake()\n\nwelder.logCache.size should be(__)\nbaker.logCache.size should be(__)","mode":"scala","solutions":["1","1"]},"solution":"1,1"},{"id":"koan5","tag":"koan-task","data":{"description":"Traits are instantiated before a classes instantiation","code":"var sb = List[String]()\n\ntrait T1 {\n  sb = sb :+ \"In T1: x=%s\".format(x)// default value of int is 0\n  val x = 1\n  sb = sb :+ \"In T1: x=%s\".format(x)\n}\n\nclass C1 extends T1 {\n  sb = sb :+ \"In C1: y=%s\".format(y)// default value of int is 0\n  val y = 2\n  sb = sb :+ \"In C1: y=%s\".format(y)\n}\n\nsb = sb :+ \"Creating C1\"\nnew C1\nsb = sb :+ \"Created C1\"\n\nsb.mkString(\";\") should be(__)","mode":"scala","solutions":["\"Creating C1;In T1: x=0;In T1: x=1;In C1: y=0;In C1: y=2;Created C1\""]},"solution":"\"Creating C1;In T1: x=0;In T1: x=1;In C1: y=0;In C1: y=2;Created C1\""},{"id":"koan6","tag":"koan-task","data":{"description":"Traits are instantiated before a classes instantiation from left to right","code":"var sb = List[String]()\n\ntrait T1 {\n  sb = sb :+ \"In T1: x=%s\".format(x)\n  val x = 1\n  sb = sb :+ \"In T1: x=%s\".format(x)\n}\n\ntrait T2 {\n  sb = sb :+ \"In T2: z=%s\".format(z)\n  val z = 1\n  sb = sb :+ \"In T2: z=%s\".format(z)\n}\n\nclass C1 extends T1 with T2 {\n  sb = sb :+ \"In C1: y=%s\".format(y)\n  val y = 2\n  sb = sb :+ \"In C1: y=%s\".format(y)\n}\n\nsb = sb :+ \"Creating C1\"\nnew C1\nsb = sb :+ \"Created C1\"\n\nsb.mkString(\";\") should be(__)","mode":"scala","solutions":["\"Creating C1;In T1: x=0;In T1: x=1;In T2: z=0;In T2: z=1;In C1: y=0;In C1: y=2;Created C1\""]},"solution":"\"Creating C1;In T1: x=0;In T1: x=1;In T2: z=0;In T2: z=1;In C1: y=0;In C1: y=2;Created C1\""}]},{"id": 5, "title": " About  Asserts", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"asserts can take a boolean argument","code":"assert(true) // should be __","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan2","tag":"koan-task","data":{"description":"asserts can include a message","code":"assert(true, \"This should be __","mode":"scala","solutions":["true\")"]},"solution":"true\")"},{"id":"koan3","tag":"koan-task","data":{"description":"true and false values can be compared with should matchers","code":"true should be(__) // be true","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan4","tag":"koan-task","data":{"description":"booleans in asserts can test equality","code":"val v1 = 4\nval v2 = 4\nassert(v1 === __)","mode":"scala","solutions":["4"]},"solution":"4"},{"id":"koan5","tag":"koan-task","data":{"description":"sometimes we expect you to fill in the values","code":"assert(2 == __)","mode":"scala","solutions":["1 + 1"]},"solution":"1 + 1"}]},{"id": 6, "title": "About Lazy Sequences", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Creating a lazy collection from a strict collection","code":"val strictList = List(10, 20, 30)\nval lazyList = strictList.view\nlazyList.head should be(__)","mode":"scala","solutions":["10"]},"solution":"10"},{"id":"koan2","tag":"koan-task","data":{"description":"Lazy collection sometimes avoid processing errors","code":"val lazyList = List(2, -2, 0, 4).view map { 2 / _ }\nlazyList.head should be(__)\nlazyList(1) should be(__)\nintercept[ArithmeticException] {\n  lazyList(2)\n}","mode":"scala","solutions":["1","-1"]},"solution":"1,-1"},{"id":"koan3","tag":"koan-task","data":{"description":"Lazy collections could also be infinite","code":"val infinite = Stream.from(1)\ninfinite.take(4).sum should be(__)\nStream.continually(1).take(4).sum should be(__)","mode":"scala","solutions":["10","4"]},"solution":"10,4"},{"id":"koan4","tag":"koan-task","data":{"description":"Always remember tail of a lazy collection is never computed unless required","code":"def makeLazy(value: Int): Stream[Int] = {\n  Stream.cons(value, makeLazy(value + 1))\n}\nval stream = makeLazy(1)\nstream.head should be(__)\nstream.tail.head should be(__)","mode":"scala","solutions":["1","2"]},"solution":"1,2"}]},{"id": 7, "title": "About By Name Parameter", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"() => Int is a Function type that takes a Unit type and returns an Int.\n Unit is known as 'void' to a Java programmer.\n You can place this as a method parameter so that you can you use it as a block, but still\n it doesn't look quite right.","code":"def calc(x: () => Int): Either[Throwable, Int] = {\n  try {\n    Right(x()) //An explicit call to the x function\n  } catch {\n    case b: Throwable => Left(b)\n  }\n}\n\nval y = calc {() => //Having explicitly declaring that Unit is a parameter with ()\n  14 + 15\n}\n\ny should be (__)","mode":"scala","solutions":["Right(29)"]},"solution":"Right(29)"},{"id":"koan2","tag":"koan-task","data":{"description":"A by-name parameter does the same thing as a previous koan but there is no need to explicitly\n handle Unit or (). This is used extensively in scala to create blocks.","code":"def calc(x: => Int): Either[Throwable, Int] = {   //x is a call by name parameter\n  try {\n    Right(x)\n  } catch {\n    case b: Throwable => Left(b)\n  }\n}\n\nval y = calc {                                    //This looks like a natural block\n  println(\"Here we go!\")                          //Some superfluous call\n  val z = List(1, 2, 3, 4)                        //Another superfluous call\n  49 + 20\n}\n\ny should be (__)","mode":"scala","solutions":["Right(69)"]},"solution":"Right(69)"},{"id":"koan3","tag":"koan-task","data":{"description":"By name parameters can also be used with an Object and apply to make interesting block-like calls","code":"object PigLatinizer {\n  def apply(x: => String) = x.tail + x.head + \"ay\"\n}\n\nval result = PigLatinizer {\n  val x = \"pret\"\n  val z = \"zel\"\n  x ++ z //concatenate the strings\n}\n\nresult should be (__)","mode":"scala","solutions":["\"retzelpay\""]},"solution":"\"retzelpay\""}]},{"id": 8, "title": "About Objects", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"An object is a singleton. One object -- that's it. This object is a replacement of static in Java,\n and is called upon much in the same way","code":"object Greeting {\n  def english = \"Hi\"\n\n  def espanol = \"Hola\"\n\n  def deutsch = \"Hallo\"\n\n  def magyar = \"Szia\"\n}\n\nGreeting.english should be(__)\nGreeting.espanol should be(__)\nGreeting.deutsch should be(__)\nGreeting.magyar should be(__)","mode":"scala","solutions":["\"Hi\"","\"Hola\"","\"Hallo\"","\"Szia\""]},"solution":"\"Hi\",\"Hola\",\"Hallo\",\"Szia\""},{"id":"koan2","tag":"koan-task","data":{"description":"Here is proof an object is a singleton, and not a static method in a class","code":"object Greeting {\n  def english = \"Hi\"\n\n  def espanol = \"Hola\"\n\n  def deutsch = \"Hallo\"\n\n  def magyar = \"Szia\"\n}\n\nval x = Greeting\nval y = x\n\nx eq y should be(__) //Reminder, eq checks for reference\n\nval z = Greeting\n\nx eq z should be(__)","mode":"scala","solutions":["true","true"]},"solution":"true,true"},{"id":"koan3","tag":"koan-task","data":{"description":"An object that has the same name as class is called a companion object,\n it is used to contain factories for the class that it complements","code":"class Movie(val name: String, val year: Short)\n\nobject Movie {\n  def academyAwardBestMoviesForYear(x: Short) = {\n    //These are match statement, more powerful than Java switch statements!\n    x match {\n      case 1930 => Some(new Movie(\"All Quiet On the Western Front\", 1930))\n      case 1931 => Some(new Movie(\"Cimarron\", 1931))\n      case 1932 => Some(new Movie(\"Grand Hotel\", 1931))\n      case _ => None\n    }\n  }\n}\n\nMovie.academyAwardBestMoviesForYear(1932).get.name should be(__)","mode":"scala","solutions":["\"Grand Hotel\""]},"solution":"\"Grand Hotel\""},{"id":"koan4","tag":"koan-task","data":{"description":"A companion object stores shared variables and values for every instantiated class to share.\n (See SecretAgent class and companion object above).","code":"val bond = new SecretAgent(\"James Bond\")\nval felix = new SecretAgent(\"Felix Leitner\")\nval jason = new SecretAgent(\"Jason Bourne\")\nval _99 = new SecretAgent(\"99\")\nval max = new SecretAgent(\"Max Smart\")\n\nbond.shoot(800)\nfelix.shoot(200)\njason.shoot(150)\n_99.shoot(150)\nmax.shoot(200)\n\nSecretAgent.bullets should be(__)","mode":"scala","solutions":["1500"]},"solution":"1500"},{"id":"koan5","tag":"koan-task","data":{"description":"A companion object can also see private values and variables of the instantiated objects","code":"val clark = new Person(\"Clark Kent\", \"Superman\")\nval peter = new Person(\"Peter Parker\", \"Spiderman\")\nval bruce = new Person(\"Bruce Wayne\", \"Batman\")\nval diana = new Person(\"Diana Prince\", \"Wonder Woman\")\n\nPerson.showMeInnerSecret(clark) should be (__)\nPerson.showMeInnerSecret(peter) should be (__)\nPerson.showMeInnerSecret(bruce) should be (__)\nPerson.showMeInnerSecret(diana) should be (__)","mode":"scala","solutions":["\"Superman\"","\"Spiderman\"","\"Batman\"","\"Wonder Woman\""]},"solution":"\"Superman\",\"Spiderman\",\"Batman\",\"Wonder Woman\""}]},{"id": 9, "title": "About Constructors", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Primary constructor specified with a parameter requires that parameter to be passed in","code":"val aboutMe = new AboutConstructorWithAuxiliaryConstructor()\naboutMe.name should be (__)","mode":"scala","solutions":["\"defaultname\""]},"solution":"\"defaultname\""},{"id":"koan2","tag":"koan-task","data":{"description":"Class with no class parameters is called with no arguments","code":"// add parameter to make this fail\nval aboutMe = new AboutClassWithNoClassParameter","mode":"scala","solutions":[]},"solution":""}]},{"id": 10, "title": "About Literal Numbers", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Integer Literals are 32-bit and can be created from decimal, hexadecimal","code":"val a = 2\nval b = 31\nval c = 0x30F\nval e = 0\nval f = -2\nval g = -31\nval h = -0x30F\na should be(__)\nb should be(__)\nc should be(__) //Hint: 30F = 783\ne should be(__)\nf should be(__)\ng should be(__)\nh should be(__) //Hint: 30F = 783","mode":"scala","solutions":["2","31","783","0","-2","-31","-783"]},"solution":"2,31,783,0,-2,-31,-783"},{"id":"koan2","tag":"koan-task","data":{"description":"Long Literals are 64 bit, are specified by appending an L or l at the end;\n   l is rarely used since it looks like a 1","code":"val a = 2L\nval b = 31L\nval c = 0x30FL\nval e = 0L\nval f = -2l\nval g = -31L\nval h = -0x30FL\n\na should be(__)\nb should be(__)\nc should be(__) //Hint: 30F = 783\ne should be(__)\nf should be(__)\ng should be(__)\nh should be(__) //Hint: 30F = 783","mode":"scala","solutions":["2L","31L","783L","0L","-2L","-31L","-783L"]},"solution":"2L,31L,783L,0L,-2L,-31L,-783L"},{"id":"koan3","tag":"koan-task","data":{"description":"Float and Double Literals are IEEE 754 for specific,\n   Float are 32-bit length, Doubles are 64-bit.\n   Floats can be coerced using a f or F suffix, and\n   Doubles can be coerced using a d or D suffix.\n   Exponent are specified using e or E.","code":"val a = 3.0\nval b = 3.00\nval c = 2.73\nval d = 3f\nval e = 3.22d\nval f = 93e-9\nval g = 93E-9\nval h = 0.0\nval i = 9.23E-9D\n\na should be(__)\nb should be(__)\nc should be(__)\nd should be(__)\ne should be(__)\nf should be(__)\ng should be(__)\nh should be(__)\ni should be(__)","mode":"scala","solutions":["3.0","3.0","2.73","3.0","3.22d","93e-9","93e-9","0","9.23e-9d"]},"solution":"3.0,3.0,2.73,3.0,3.22d,93e-9,93e-9,0,9.23e-9d"}]},{"id": 11, "title": "About Sets", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Sets can be created easily","code":"val mySet = Set(\"Michigan\", \"Ohio\", \"Wisconsin\", \"Iowa\")\nmySet.size should be(__)","mode":"scala","solutions":["4"]},"solution":"4"},{"id":"koan2","tag":"koan-task","data":{"description":"Sets contain distinct values","code":"val mySet = Set(\"Michigan\", \"Ohio\", \"Wisconsin\", \"Michigan\")\nmySet.size should be(__)","mode":"scala","solutions":["3"]},"solution":"3"},{"id":"koan3","tag":"koan-task","data":{"description":"Sets can be added to easily","code":"val mySet = Set(\"Michigan\", \"Ohio\", \"Wisconsin\", \"Iowa\")\nval aNewSet = mySet + \"Illinois\"\n\naNewSet.contains(\"Illinois\") should be(__)","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan4","tag":"koan-task","data":{"description":"Sets may be of mixed type","code":"val mySet = Set(\"Michigan\", \"Ohio\", 12)\n\nmySet.contains(12) should be(__)\n\nmySet.contains(\"MI\") should be(__)","mode":"scala","solutions":["true","false"]},"solution":"true,false"},{"id":"koan5","tag":"koan-task","data":{"description":"Sets may be accessed","code":"val mySet = Set(\"Michigan\", \"Ohio\", 12)\n\nmySet(12) should be(__)\nmySet(\"MI\") should be(__)","mode":"scala","solutions":["true","false"]},"solution":"true,false"},{"id":"koan6","tag":"koan-task","data":{"description":"Set elements can be removed easily","code":"val mySet = Set(\"Michigan\", \"Ohio\", \"Wisconsin\", \"Iowa\")\nval aNewSet = mySet - \"Michigan\"\n\naNewSet.contains(\"Michigan\") should be(__)","mode":"scala","solutions":["false"]},"solution":"false"},{"id":"koan7","tag":"koan-task","data":{"description":"Set elements can be removed in multiple","code":"val mySet = Set(\"Michigan\", \"Ohio\", \"Wisconsin\", \"Iowa\")\nval aNewSet = mySet -- List(\"Michigan\", \"Ohio\")\n\naNewSet.contains(\"Michigan\") should be(__)\naNewSet.contains(\"Wisconsin\") should be(__)\naNewSet.size should be(__)","mode":"scala","solutions":["false","true","2"]},"solution":"false,true,2"},{"id":"koan8","tag":"koan-task","data":{"description":"Set elements can be removed with a tuple","code":"val mySet = Set(\"Michigan\", \"Ohio\", \"Wisconsin\", \"Iowa\")\nval aNewSet = mySet - (\"Michigan\", \"Ohio\") // Notice: single '-' operator for tuples\n\naNewSet.contains(\"Michigan\") should be(__)\naNewSet.contains(\"Wisconsin\") should be(__)\naNewSet.size should be(__)","mode":"scala","solutions":["false","true","2"]},"solution":"false,true,2"},{"id":"koan9","tag":"koan-task","data":{"description":"Attempted removal of nonexistent elements from a set is handled gracefully","code":"val mySet = Set(\"Michigan\", \"Ohio\", \"Wisconsin\", \"Iowa\")\nval aNewSet = mySet - \"Minnesota\"\n\naNewSet.equals(mySet) should be(__)","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan10","tag":"koan-task","data":{"description":"Sets can be iterated easily","code":"val mySet = Set(1, 3, 4, 9)\nvar sum = 0\nfor (i <- mySet)\n  sum = sum + i\n\nsum should be(__)","mode":"scala","solutions":["17"]},"solution":"17"},{"id":"koan11","tag":"koan-task","data":{"description":"Two sets can be intersected easily","code":"val mySet1 = Set(\"Michigan\", \"Ohio\", \"Wisconsin\", \"Iowa\")\nval mySet2 = Set(\"Wisconsin\", \"Michigan\", \"Minnesota\")\nval aNewSet = mySet1 intersect mySet2\n// NOTE: Scala 2.7 used **, deprecated for & or intersect in Scala 2.8\n\naNewSet.equals(Set(\"Michigan\", \"Wisconsin\")) should be(__)","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan12","tag":"koan-task","data":{"description":"Two sets can be joined as their union easily","code":"val mySet1 = Set(\"Michigan\", \"Ohio\", \"Wisconsin\", \"Iowa\")\nval mySet2 = Set(\"Wisconsin\", \"Michigan\", \"Minnesota\")\nval aNewSet = mySet1 union mySet2 // NOTE: You can also use the \"|\" operator\n\naNewSet.equals(Set(\"Michigan\", \"Wisconsin\", \"Ohio\", \"Iowa\", \"Minnesota\")) should be(__)","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan13","tag":"koan-task","data":{"description":"A set is either a subset of another set or it isn't","code":"val mySet1 = Set(\"Michigan\", \"Ohio\", \"Wisconsin\", \"Iowa\")\nval mySet2 = Set(\"Wisconsin\", \"Michigan\", \"Minnesota\")\nval mySet3 = Set(\"Wisconsin\", \"Michigan\")\n\nmySet2 subsetOf mySet1 should be(__)\nmySet3 subsetOf mySet1 should be(__)","mode":"scala","solutions":["false","true"]},"solution":"false,true"},{"id":"koan14","tag":"koan-task","data":{"description":"The difference between two sets can be obtained easily","code":"val mySet1 = Set(\"Michigan\", \"Ohio\", \"Wisconsin\", \"Iowa\")\nval mySet2 = Set(\"Wisconsin\", \"Michigan\")\nval aNewSet = mySet1 diff mySet2 // Note: you can use the \"&~\" operator if you *really* want to.\n\naNewSet.equals(Set(\"Ohio\", \"Iowa\")) should be(__)","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan15","tag":"koan-task","data":{"description":"Set equivalency is independent of order","code":"val mySet1 = Set(\"Michigan\", \"Ohio\", \"Wisconsin\", \"Iowa\")\nval mySet2 = Set(\"Wisconsin\", \"Michigan\", \"Ohio\", \"Iowa\")\n\nmySet1.equals(mySet2) should be(__)","mode":"scala","solutions":["true"]},"solution":"true"}]},{"id": 12, "title": "About Traversables", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Traverables are the superclass of Lists, Arrays, Maps, Sets, Streams, and more.\n   The methods involved can be applied to each other in a different type.  ++ appends\n   two Traversables together.","code":"val set = Set(1, 9, 10, 22)\nval list = List(3, 4, 5, 10)\nval result = set ++ list\nresult.size should be(__)\n\nval result2 = list ++ set\nresult2.size should be(__)","mode":"scala","solutions":["7","8"]},"solution":"7,8"},{"id":"koan2","tag":"koan-task","data":{"description":"map will apply the given function on all elements of a\n  Traversable and return a new collection of the result.","code":"val set = Set(1, 3, 4, 6)\nval result = set.map(_ * 4)\nresult.last should be(__)","mode":"scala","solutions":["24"]},"solution":"24"},{"id":"koan3","tag":"koan-task","data":{"description":"flatten will smash all child Traversables within a Traversable","code":"val list = List(List(1), List(2, 3, 4), List(5, 6, 7), List(8, 9, 10))\nlist.flatten should be(__)","mode":"scala","solutions":["1 to 10"]},"solution":"1 to 10"},{"id":"koan4","tag":"koan-task","data":{"description":"flatMap will not only apply the given function on all elements of a Traversable,\n  but all elements within the elements and flatten the results","code":"val list = List(List(1), List(2, 3, 4), List(5, 6, 7), List(8, 9, 10))\nval result = list.flatMap(_.map(_ * 4))\nresult should be(__)","mode":"scala","solutions":["(1 to 10) map (_ * 4)"]},"solution":"(1 to 10) map (_ * 4)"},{"id":"koan5","tag":"koan-task","data":{"description":"flatMap of Options will filter out all Nones and Keep the Somes","code":"val list = List(1, 2, 3, 4, 5)\nval result = list.flatMap(it => if (it % 2 == 0) Some(it) else None)\nresult should be(__)","mode":"scala","solutions":["List(2, 4)"]},"solution":"List(2, 4)"},{"id":"koan6","tag":"koan-task","data":{"description":"collect will apply a partial function to all elements of a Traversable\n          and will return a different collection. In this koan, a case fragment is a partial function.","code":"val list = List(4, 6, 7, 8, 9, 13, 14)\nval result = list.collect {\n  case x: Int if (x % 2 == 0) => x * 3\n}\nresult should be(__)","mode":"scala","solutions":["List(12, 18, 24, 42)"]},"solution":"List(12, 18, 24, 42)"},{"id":"koan7","tag":"koan-task","data":{"description":"collect will apply a partial function to all elements of a Traversable\n  and will return a different collection. In this koan, two case fragments are chained to create\n  a more robust result.","code":"val list = List(4, 6, 7, 8, 9, 13, 14)\nval partialFunction1: PartialFunction[Int, Int] = {\n  case x: Int if x % 2 == 0 => x * 3\n}\nval partialFunction2: PartialFunction[Int, Int] = {\n  case y: Int if y % 2 != 0 => y * 4\n}\nval result = list.collect(partialFunction1 orElse partialFunction2)\nresult should be(__)","mode":"scala","solutions":["List(12, 18, 28, 24, 36, 52, 42)"]},"solution":"List(12, 18, 28, 24, 36, 52, 42)"},{"id":"koan8","tag":"koan-task","data":{"description":"foreach will apply a function to all elements of a Traversable, but unlike\n the map function, it will not return anything since the return type is Unit, which\n is like a void return type in Java, C++","code":"val list = List(4, 6, 7, 8, 9, 13, 14)\nlist.foreach(num => println(num * 4))\nlist should be(__)","mode":"scala","solutions":["List(4, 6, 7, 8, 9, 13, 14)"]},"solution":"List(4, 6, 7, 8, 9, 13, 14)"},{"id":"koan9","tag":"koan-task","data":{"description":"toArray will convert any Traversable to an Array, which is a special wrapper around a\n  primitive Java array.","code":"val set = Set(4, 6, 7, 8, 9, 13, 14)\nval result = set.toArray\nresult.isInstanceOf[Array[Int]] should be(__)","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan10","tag":"koan-task","data":{"description":"toList will convert any Traversable to a List.","code":"val set = Set(4, 6, 7, 8, 9, 13, 14)\nval result = set.toList\n\nresult.isInstanceOf[List[_]] should be(__)","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan11","tag":"koan-task","data":{"description":"toList, as well as other conversion methods like toSet, toArray,\n  will not convert if the collection type is the same.","code":"val list = List(5, 6, 7, 8, 9)\nval result = list.toList\nresult eq list should be(__) //Reminder: eq tests for reference equality","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan12","tag":"koan-task","data":{"description":"toIterable will convert any Traversable to an Iterable. This is a base\n  trait for all Scala collections that define an iterator method to step\n  through one-by-one the collection's elements.\n  (see AboutIterable koan).","code":"val set = Set(4, 6, 7, 8, 9, 13, 14)\nval result = set.toIterable\nresult.isInstanceOf[Iterable[_]] should be(__)","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan13","tag":"koan-task","data":{"description":"toSeq will convert any Traversable to a Seq which is an ordered Iterable\n  and is the superclass to List, Queues, and Vectors.  Sequences provide\n  a method apply for indexing. Indices range from 0 up the the\n  length of a sequence.","code":"val set = Set(4, 6, 7, 8, 9, 13, 14)\nval result = set.toSeq\nresult.isInstanceOf[Seq[_]] should be(__)","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan14","tag":"koan-task","data":{"description":"toIndexedSeq will convert any Traversable to an IndexedSeq which is\n  an indexed sequence used in\n  Vectors and Strings","code":"val set = Set(4, 6, 7, 8, 9, 13, 14)\nval result = set.toIndexedSeq\nresult.isInstanceOf[IndexedSeq[_]] should be(__)","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan15","tag":"koan-task","data":{"description":"toStream will convert any Traversable to a Stream which is\n  a lazy lists where elements are evaluated as they\n  are needed.","code":"val list = List(4, 6, 7, 8, 9, 13, 14)\nval result = list.toStream\nresult.isInstanceOf[Stream[_]] should be(__)\n(result take 3) should be(__)","mode":"scala","solutions":["true","List(4, 6, 7)"]},"solution":"true,List(4, 6, 7)"},{"id":"koan16","tag":"koan-task","data":{"description":"toSet will convert any Traversable to a Set which is\n  a collection of unordered, unique values","code":"val list = List(4, 6, 7, 8, 9, 13, 14)\nval result = list.toSet\nresult.isInstanceOf[Set[_]] should be(__)","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan17","tag":"koan-task","data":{"description":"toMap will convert any Traversable to a Map.  How it's\n used, depends on the original collection, if it's a List or Seq,\n it should be of parameterized type Tuple2.","code":"val list = List(\"Phoenix\" -> \"Arizona\", \"Austin\" -> \"Texas\")\nval result = list.toMap\nresult.isInstanceOf[Map[_, _]] should be(__)","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan18","tag":"koan-task","data":{"description":"toMap will convert a Set to a Map,\n it should be of parameterized type Tuple2.","code":"val set = Set(\"Phoenix\" -> \"Arizona\", \"Austin\" -> \"Texas\")\nval result = set.toMap\nresult.isInstanceOf[Map[_, _]] should be(__)","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan19","tag":"koan-task","data":{"description":"isEmpty is pretty self evident","code":"val map = Map(\"Phoenix\" -> \"Arizona\", \"Austin\" -> \"Texas\")\nmap.isEmpty should be(__)\n\nval set = Set()\nset.isEmpty should be(__)","mode":"scala","solutions":["false","true"]},"solution":"false,true"},{"id":"koan20","tag":"koan-task","data":{"description":"nonEmpty is pretty self evident too","code":"val map = Map(\"Phoenix\" -> \"Arizona\", \"Austin\" -> \"Texas\")\nmap.nonEmpty should be(__)\n\nval set = Set()\nset.nonEmpty should be(__)","mode":"scala","solutions":["true","false"]},"solution":"true,false"},{"id":"koan21","tag":"koan-task","data":{"description":"size provides the size of the traversable","code":"val map = Map(\"Phoenix\" -> \"Arizona\", \"Austin\" -> \"Texas\")\nmap.size should be(__)","mode":"scala","solutions":["2"]},"solution":"2"},{"id":"koan22","tag":"koan-task","data":{"description":"hasDefiniteSize will return true if there is traversable that has a\n          finite end, otherwise false","code":"val map = Map(\"Phoenix\" -> \"Arizona\", \"Austin\" -> \"Texas\")\nmap.hasDefiniteSize should be(__)\n\nimport Stream.cons\nval stream = cons(0, cons(1, Stream.empty))\nstream.hasDefiniteSize should be(__)","mode":"scala","solutions":["true","false"]},"solution":"true,false"},{"id":"koan23","tag":"koan-task","data":{"description":"head will return the first element of an ordered collection, or some random\n element if order is not defined like in a Set or Map","code":"val list = List(10, 19, 45, 1, 22)\nlist.head should be(__)","mode":"scala","solutions":["10"]},"solution":"10"},{"id":"koan24","tag":"koan-task","data":{"description":"headOption will return the first element as an Option of an order collection,\n or some random element if order is not defined.  If a first element\n is not available, then None is returned","code":"val list = List(10, 19, 45, 1, 22)\nlist.headOption should be(__)\n\nval list2 = List()\nlist2.headOption should be(__)","mode":"scala","solutions":["Some(10)","None"]},"solution":"Some(10),None"},{"id":"koan25","tag":"koan-task","data":{"description":"last will return the last element of an ordered collection, or some random\n element if order is not defined like in a Set or Map","code":"val list = List(10, 19, 45, 1, 22)\nlist.last should be(__)","mode":"scala","solutions":["22"]},"solution":"22"},{"id":"koan26","tag":"koan-task","data":{"description":"lastOption will return the last element as an Option of an order collection,\n or some random element if order is not defined.  If a first element\n is not available, then None is returned","code":"val list = List(10, 19, 45, 1, 22)\nlist.lastOption should be(__)\n\nval list2 = List()\nlist2.lastOption should be(__)","mode":"scala","solutions":["Some(22)","None"]},"solution":"Some(22),None"},{"id":"koan27","tag":"koan-task","data":{"description":"find will locate the first item that matches a predicate p as Some or None if\n an element is not found","code":"val list = List(10, 19, 45, 1, 22)\nlist.find(_ % 2 != 0) should be(__)\n\nval list2 = List(4, 8, 16)\nlist2.find(_ % 2 != 0) should be(__)","mode":"scala","solutions":["Some(19)","None"]},"solution":"Some(19),None"},{"id":"koan28","tag":"koan-task","data":{"description":"tail will return the rest of the collection without the head","code":"val list = List(10, 19, 45, 1, 22)\nlist.tail should be(__)","mode":"scala","solutions":["List(19, 45, 1, 22)"]},"solution":"List(19, 45, 1, 22)"},{"id":"koan29","tag":"koan-task","data":{"description":"init will return the rest of the collection without the last","code":"val list = List(10, 19, 45, 1, 22)\nlist.init should be(__)","mode":"scala","solutions":["List(10, 19, 45, 1)"]},"solution":"List(10, 19, 45, 1)"},{"id":"koan30","tag":"koan-task","data":{"description":"Given a `from` index, and a `to` index, slice will return the part of the\n  collection including `from`, and excluding `to`","code":"val list = List(10, 19, 45, 1, 22)\nlist.slice(1, 3) should be(__)","mode":"scala","solutions":["List(19, 45)"]},"solution":"List(19, 45)"},{"id":"koan31","tag":"koan-task","data":{"description":"Take will return the the first number of elements given.","code":"val list = List(10, 19, 45, 1, 22)\nlist.take(3) should be(__)","mode":"scala","solutions":["List(10, 19, 45)"]},"solution":"List(10, 19, 45)"},{"id":"koan32","tag":"koan-task","data":{"description":"Take is used often with Streams, and Streams after all are Traversable","code":"def streamer(v: Int): Stream[Int] = cons(v, streamer(v + 1))\nval a = streamer(2)\n(a take 3 toList) should be(__)","mode":"scala","solutions":["List(2, 3, 4)"]},"solution":"List(2, 3, 4)"},{"id":"koan33","tag":"koan-task","data":{"description":"Drop will take the rest of the Traversable except\n  the number of elements given","code":"def streamer(v: Int): Stream[Int] = cons(v, streamer(v + 1))\nval a = streamer(2)\n((a drop 6) take 3).toList should be(__)","mode":"scala","solutions":["List(8, 9, 10)"]},"solution":"List(8, 9, 10)"},{"id":"koan34","tag":"koan-task","data":{"description":"takeWhile will continually accumulate elements until a predicate\n  is no longer satisfied.  In this koan, TreeSet is Traversable.\n  TreeSet also is also sorted.","code":"val list = List(87, 44, 5, 4, 200, 10, 39, 100)\nlist.takeWhile(_ < 100) should be(__)","mode":"scala","solutions":["List(87, 44, 5, 4)"]},"solution":"List(87, 44, 5, 4)"},{"id":"koan35","tag":"koan-task","data":{"description":"dropWhile will continually drop elements until a predicate\n  is no longer satisfied.  Again, TreeSet is Traversable.\n  TreeSet also is also sorted.","code":"val list = List(87, 44, 5, 4, 200, 10, 39, 100)\nlist.dropWhile(_ < 100) should be(__)","mode":"scala","solutions":["List(200, 10, 39, 100)"]},"solution":"List(200, 10, 39, 100)"},{"id":"koan36","tag":"koan-task","data":{"description":"filter will take out all elements that don't satisfy a predicate. An\n  Array is also Traversable.","code":"val array = Array(87, 44, 5, 4, 200, 10, 39, 100)\narray.filter(_ < 100) should be(__)","mode":"scala","solutions":["Array(87, 44, 5, 4, 10, 39)"]},"solution":"Array(87, 44, 5, 4, 10, 39)"},{"id":"koan37","tag":"koan-task","data":{"description":"filterNot will take out all elements that satisfy a predicate. An\n  Array is also Traversable.","code":"val array = Array(87, 44, 5, 4, 200, 10, 39, 100)\narray.filterNot(_ < 100) should be(__)","mode":"scala","solutions":["Array(200, 100)"]},"solution":"Array(200, 100)"},{"id":"koan38","tag":"koan-task","data":{"description":"splitAt will split a Traversable at a position, returning a 2 product\n  Tuple.  Array is Traversable. splitAt is also defined as\n  (xs take n, xs drop n)","code":"val array = Array(87, 44, 5, 4, 200, 10, 39, 100)\nval result = array splitAt 3\nresult._1 should be(__)\nresult._2 should be(__)","mode":"scala","solutions":["Array(87, 44, 5)","Array(4, 200, 10, 39, 100)"]},"solution":"Array(87, 44, 5),Array(4, 200, 10, 39, 100)"},{"id":"koan39","tag":"koan-task","data":{"description":"span will split a Traversable according to predicate, returning\n  a 2 product Tuple.  Array is Traversable, span\n  is also defined as (xs takeWhile p, xs dropWhile p)","code":"val array = Array(87, 44, 5, 4, 200, 10, 39, 100)\nval result = array span (_ < 100)\nresult._1 should be(__)\nresult._2 should be(__)","mode":"scala","solutions":["Array(87, 44, 5, 4)","Array(200, 10, 39, 100)"]},"solution":"Array(87, 44, 5, 4),Array(200, 10, 39, 100)"},{"id":"koan40","tag":"koan-task","data":{"description":"partition will split a Traversable according to predicate, return\n  a 2 product Tuple. The left side are the elements satisfied by\n  the predicate, the right side is not. Array is Traversable,\n  partition is also defined as (xs filter p, xs filterNot p)","code":"val array = Array(87, 44, 5, 4, 200, 10, 39, 100)\nval result = array partition (_ < 100)\nresult._1 should be(__)\nresult._2 should be(__)","mode":"scala","solutions":["Array(87, 44, 5, 4, 10, 39)","Array(200, 100)"]},"solution":"Array(87, 44, 5, 4, 10, 39),Array(200, 100)"},{"id":"koan41","tag":"koan-task","data":{"description":"groupBy will categorize a Traversable according to function, and return\n          a map with the results.  This koan uses Partial Function chaining.  If you are\n          still unfamiliar with PartialFunctions, see AboutPartialFunctions koans.","code":"val array = Array(87, 44, 5, 4, 200, 10, 39, 100)\n\nval oddAndSmallPartial: PartialFunction[Int, String] = {\n  case x: Int if x % 2 != 0 && x < 100 => \"Odd and less than 100\"\n}\n\nval evenAndSmallPartial: PartialFunction[Int, String] = {\n  case x: Int if x != 0 && x % 2 == 0 && x < 100 => \"Even and less than 100\"\n}\n\nval negativePartial: PartialFunction[Int, String] = {\n  case x: Int if x < 0 => \"Negative Number\"\n}\n\nval largePartial: PartialFunction[Int, String] = {\n  case x: Int if x > 99 => \"Large Number\"\n}\n\nval zeroPartial: PartialFunction[Int, String] = {\n  case x: Int if x == 0 => \"Zero\"\n}\n\nval result = array groupBy {\n    oddAndSmallPartial orElse\n    evenAndSmallPartial orElse\n    negativePartial orElse\n    largePartial orElse\n    zeroPartial\n}\n\n(result(\"Even and less than 100\") size) should be(__)\n(result(\"Large Number\") size) should be(__)","mode":"scala","solutions":["3","2"]},"solution":"3,2"},{"id":"koan42","tag":"koan-task","data":{"description":"forall will determine if a predicate is valid for all members of a\n  Traversable.","code":"val list = List(87, 44, 5, 4, 200, 10, 39, 100)\nval result = list forall (_ < 100)\nresult should be(__)","mode":"scala","solutions":["false"]},"solution":"false"},{"id":"koan43","tag":"koan-task","data":{"description":"`exists` will determine if a predicate\n is valid for some members of a Traversable.","code":"val list = List(87, 44, 5, 4, 200, 10, 39, 100)\nval result = list exists (_ < 100)\nresult should be(__)","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan44","tag":"koan-task","data":{"description":"`count` will count the number of elements that satisfy a predicate\n in a Traversable.","code":"val list = List(87, 44, 5, 4, 200, 10, 39, 100)\nval result = list count (_ < 100)\nresult should be(__)","mode":"scala","solutions":["6"]},"solution":"6"},{"id":"koan45","tag":"koan-task","data":{"description":" `/:` or `foldLeft` will combine an operation starting with a seed and combining from the left.  Fold Left\n is defined as (seed /: list), where seed is the initial value.  Once the fold is established, you\n provide a function that takes two arguments.  The first argument is the running total of the operation,\n and the second element is the next element of the list.\n\n Given a Traversable (x1, x2, x3, x4), an initial value of init, an operation op,\n foldLeft is defined as: (((init op x1) op x2) op x3) op x4)","code":"val list = List(5, 4, 3, 2, 1)\nval result = (0 /: list) {\n  (`running total`, `next element`) => `running total` - `next element`\n}\nresult should be(__)\n\nval result2 = list.foldLeft(0) {\n  (`running total`, `next element`) => `running total` - `next element`\n}\nresult2 should be(__)\n\nval result3 = (0 /: list)(_ - _) //Short hand\nresult3 should be(__)\n\nval result4 = list.foldLeft(0)(_ - _)\nresult4 should be(__)\n\n(((((0 - 5) - 4) - 3) - 2) - 1) should be(__)","mode":"scala","solutions":["-15","-15","-15","-15","-15"]},"solution":"-15,-15,-15,-15,-15"},{"id":"koan46","tag":"koan-task","data":{"description":" `:\\` or foldRight` will combine an operation starting with a seed and combining from the right.  Fold right\n is defined as (list :\\ seed), where seed is the initial value.  Once the fold is established, you\n provide a function that takes two elements.  The first is the next element of the list, and the\n second element is the running total of the operation.\n\n Given a Traversable (x1, x2, x3, x4), an initial value of init, an operation op,\n foldRight is defined as: x1 op (x2 op (x3 op (x4 op init)))","code":"val list = List(5, 4, 3, 2, 1)\nval result = (list :\\ 0) {\n  (`next element`, `running total`) => `next element` - `running total`\n}\nresult should be(__)\n\nval result2 = (list foldRight 0) {\n  (`next element`, `running total`) => `next element` - `running total`\n}\nresult2 should be(__)\n\nval result3 = (list :\\ 0)(_ - _) //Short hand\nresult3 should be(__)\n\nval result4 = list.foldRight(0)(_ - _)\nresult4 should be(__)\n\n(5 - (4 - (3 - (2 - (1 - 0))))) should be(__)","mode":"scala","solutions":["3","3","3","3","3"]},"solution":"3,3,3,3,3"},{"id":"koan47","tag":"koan-task","data":{"description":"`reduceLeft` is the similar to foldLeft, except that the seed is the head value","code":"val intList = List(5, 4, 3, 2, 1)\nintList.reduceLeft {\n  _ + _\n} should be(__)\n\nval stringList = List(\"Do\", \"Re\", \"Me\", \"Fa\", \"So\", \"La\", \"Te\", \"Do\")\nstringList.reduceLeft {\n  _ + _\n} should be(__)","mode":"scala","solutions":["15","\"DoReMeFaSoLaTeDo\""]},"solution":"15,\"DoReMeFaSoLaTeDo\""},{"id":"koan48","tag":"koan-task","data":{"description":"`reduceRight` is the similar to foldRight, except that the seed is the last value","code":"val intList = List(5, 4, 3, 2, 1)\nintList.reduceRight {\n  _ + _\n} should be(__)\n\nval stringList = List(\"Do\", \"Re\", \"Me\", \"Fa\", \"So\", \"La\", \"Te\", \"Do\")\nstringList.reduceRight {\n  _ + _\n} should be(__)","mode":"scala","solutions":["15","\"DoReMeFaSoLaTeDo\""]},"solution":"15,\"DoReMeFaSoLaTeDo\""},{"id":"koan49","tag":"koan-task","data":{"description":"There are some methods that take much of the folding work out by providing basic functionality.\n  `sum` will add all the elements, product will multiply, min would determine the smallest element, and\n  `max` the largest.","code":"val intList = List(5, 4, 3, 2, 1)\nintList.sum should be(__)\nintList.product should be(__)\nintList.max should be(__)\nintList.min should be(__)","mode":"scala","solutions":["15","120","5","1"]},"solution":"15,120,5,1"},{"id":"koan50","tag":"koan-task","data":{"description":"You would choose foldLeft/reduceLeft or foldRight/reduceRight based on your mathematical goal.\n One other reason for deciding is performance.  foldLeft is more performant since it uses\n tail recursion and is optimized. This koan will either work or you will receive a\n StackOverflowError. If you do receive a StackOverflowError, try reducing the MAX_SIZE value.","code":"val MAX_SIZE = 1000000\nval reduceLeftStartTime = new java.util.Date\n(1 to MAX_SIZE) reduceLeft (_ + _)\nval reduceLeftEndTime = new java.util.Date\n\nval reduceRightStartTime = new java.util.Date\n(1 to MAX_SIZE) reduceRight (_ + _)\nval reduceRightEndTime = new java.util.Date\n\nval totalReduceLeftTime = reduceLeftEndTime.getTime - reduceLeftStartTime.getTime\nval totalReduceRightTime = reduceRightEndTime.getTime - reduceRightStartTime.getTime\n\n(totalReduceRightTime > totalReduceLeftTime) should be(__)","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan51","tag":"koan-task","data":{"description":"`transpose` will take a traversable of traversables and group them by their position in\n  it's own traversable.  E.g. ((x1, x2),(y1, y2)).transpose = (x1, y1), (x2, y2).\n  or ((x1, x2),(y1, y2),(z1, z2)).transpose = ((x1, y1, z1), (x2, y2, z2), (x3, y3, z3))","code":"val list = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))\nlist.transpose should be(__)\n\nval list2 = List(List(1), List(4))\nlist2.transpose should be(__)","mode":"scala","solutions":["List(List(1, 4, 7), List(2, 5, 8), List(3, 6, 9))","List(List(1, 4))"]},"solution":"List(List(1, 4, 7), List(2, 5, 8), List(3, 6, 9)),List(List(1, 4))"},{"id":"koan52","tag":"koan-task","data":{"description":"`mkString` will format a Traversable using a given string as the delimiter.","code":"val list = List(1, 2, 3, 4, 5)\nlist.mkString(\",\") should be(__)","mode":"scala","solutions":["\"1,2,3,4,5\""]},"solution":"\"1,2,3,4,5\""},{"id":"koan53","tag":"koan-task","data":{"description":"`mkString` will also take a beginning and ending string to surround the list.","code":"val list = List(1, 2, 3, 4, 5)\nlist.mkString(\">\", \",\", \"<\") should be(__)","mode":"scala","solutions":["\">1,2,3,4,5<\""]},"solution":"\">1,2,3,4,5<\""},{"id":"koan54","tag":"koan-task","data":{"description":"`addString` will take a StringBuilder to add the contents of list into the builder.","code":"val stringBuilder = new StringBuilder()\nval list = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)\nstringBuilder.append(\"I want all numbers 6-12: \")\nlist.filter(it => it > 5 && it < 13).addString(stringBuilder, \",\")\nstringBuilder.mkString should be(__)","mode":"scala","solutions":["\"I want all numbers 6-12: 6,7,8,9,10,11,12\""]},"solution":"\"I want all numbers 6-12: 6,7,8,9,10,11,12\""},{"id":"koan55","tag":"koan-task","data":{"description":"Traversables can have views which allow you to efficiently do compound work.","code":"val lst = List(1, 2, 3)\nvar history = List[String]()\n\ndef addHistory(s: String) {\n  history = history :+ s\n}\n\nlst.map { x => addHistory(\"Doubling %s\".format(x)); x * 2}.map\n        { x => addHistory(\"Adding 1 to %s\".format(x)); x + 1}\n\nhistory(0) should be(__)\nhistory(1) should be(__)\nhistory(2) should be(__)\nhistory(3) should be(__)\nhistory(4) should be(__)\nhistory(5) should be(__)\n\nhistory = List[String]()\n\nlst.view.map { x => addHistory(\"Doubling %s\".format(x)); x * 2}.map {\n               x => addHistory(\"Adding 1 to %s\".format(x)); x + 1}.force\n\nhistory(0) should be(__)\nhistory(1) should be(__)\nhistory(2) should be(__)\nhistory(3) should be(__)\nhistory(4) should be(__)\nhistory(5) should be(__)","mode":"scala","solutions":["\"Doubling 1\"","\"Doubling 2\"","\"Doubling 3\"","\"Adding 1 to 2\"","\"Adding 1 to 4\"","\"Adding 1 to 6\"","\"Doubling 1\"","\"Adding 1 to 2\"","\"Doubling 2\"","\"Adding 1 to 4\"","\"Doubling 3\"","\"Adding 1 to 6\""]},"solution":"\"Doubling 1\",\"Doubling 2\",\"Doubling 3\",\"Adding 1 to 2\",\"Adding 1 to 4\",\"Adding 1 to 6\",\"Doubling 1\",\"Adding 1 to 2\",\"Doubling 2\",\"Adding 1 to 4\",\"Doubling 3\",\"Adding 1 to 6\""},{"id":"koan56","tag":"koan-task","data":{"description":"Views can also accept a `to` and `from` value which takes the subseq and performs your view\n  functions on the subset.","code":"val list = List(1, 2, 3, 4, 5, 6, 7, 8)\nlist.view(3, 6).map(_ + 2).map(_ * 10).force should be(__)","mode":"scala","solutions":["List(60, 70, 80)"]},"solution":"List(60, 70, 80)"}]},{"id": 13, "title": "About  Case  Classes", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Case classes have an automatic equals method that works","code":"case class Person(first: String, last: String)\n\nval p1 = new Person(\"Fred\", \"Jones\")\nval p2 = new Person(\"Shaggy\", \"Rogers\")\nval p3 = new Person(\"Fred\", \"Jones\")\n\n(p1 == p2) should be(__)\n(p1 == p3) should be(__)\n\n(p1 eq p2) should be(__)\n(p1 eq p3) should be(__) // not identical, merely equal","mode":"scala","solutions":["false","true","false","false"]},"solution":"false,true,false,false"},{"id":"koan2","tag":"koan-task","data":{"description":"Case classes have an automatic hashcode method that works","code":"case class Person(first: String, last: String)\n\nval p1 = new Person(\"Fred\", \"Jones\")\nval p2 = new Person(\"Shaggy\", \"Rogers\")\nval p3 = new Person(\"Fred\", \"Jones\")\n\n(p1.hashCode == p2.hashCode) should be(__)\n(p1.hashCode == p3.hashCode) should be(__)","mode":"scala","solutions":["false","true"]},"solution":"false,true"},{"id":"koan3","tag":"koan-task","data":{"description":"Case classes have a convenient way they can be created","code":"case class Dog(name: String, breed: String)\n\nval d1 = Dog(\"Scooby\", \"Doberman\")\nval d2 = Dog(\"Rex\", \"Custom\")\nval d3 = new Dog(\"Scooby\", \"Doberman\") // the old way of creating using new\n\n(d1 == d3) should be(__)\n(d1 == d2) should be(__)\n(d2 == d3) should be(__)","mode":"scala","solutions":["true","false","false"]},"solution":"true,false,false"},{"id":"koan4","tag":"koan-task","data":{"description":"Case classes have a convenient toString method defined","code":"case class Dog(name: String, breed: String)\nval d1 = Dog(\"Scooby\", \"Doberman\")\nd1.toString should be(__)","mode":"scala","solutions":["\"Dog(Scooby,Doberman)\""]},"solution":"\"Dog(Scooby,Doberman)\""},{"id":"koan5","tag":"koan-task","data":{"description":"Case classes have automatic properties","code":"case class Dog(name: String, breed: String)\n\nval d1 = Dog(\"Scooby\", \"Doberman\")\nd1.name should be(__)\nd1.breed should be(__)\n\n// what happens if you uncomment the line below? Why?\n// d1 is immutable (define with val) but also, the default for field name is val so compilation error \"reassignment to val\"\n// d1.name = \"Scooby Doo\"","mode":"scala","solutions":["\"Scooby\"","\"Doberman\""]},"solution":"\"Scooby\",\"Doberman\""},{"id":"koan6","tag":"koan-task","data":{"description":"Case classes can have mutable properties","code":"case class Dog(var name: String, breed: String) // the field name is specifically marked as mutable with var, now you can rename a dog, but change its breed? nah!\nval d1 = Dog(\"Scooby\", \"Doberman\")\n\nd1.name should be(__)\nd1.breed should be(__)\n\nd1.name = \"Scooby Doo\" // but is it a good idea?\n\nd1.name should be(__)\nd1.breed should be(__)","mode":"scala","solutions":["\"Scooby\"","\"Doberman\"","\"Scooby Doo\"","\"Doberman\""]},"solution":"\"Scooby\",\"Doberman\",\"Scooby Doo\",\"Doberman\""},{"id":"koan7","tag":"koan-task","data":{"description":"Safer alternatives exist for altering case classes","code":"case class Dog(name: String, breed: String) // Doberman\n\nval d1 = Dog(\"Scooby\", \"Doberman\")\n\nval d2 = d1.copy(name = \"Scooby Doo\") // copy the case class but change the name in the copy\n\nd1.name should be(__) // original left alone\nd1.breed should be(__)\n\nd2.name should be(__)\nd2.breed should be(__) // copied from the original","mode":"scala","solutions":["\"Scooby\"","\"Doberman\"","\"Scooby Doo\"","\"Doberman\""]},"solution":"\"Scooby\",\"Doberman\",\"Scooby Doo\",\"Doberman\""},{"id":"koan8","tag":"koan-task","data":{"description":"Case classes have default and named parameters","code":"val p1 = Person(\"Fred\", \"Jones\", 23, \"111-22-3333\")\nval p2 = Person(\"Samantha\", \"Jones\") // note missing age and ssn\nval p3 = Person(last = \"Jones\", first = \"Fred\", ssn = \"111-22-3333\") // note the order can change, and missing age\nval p4 = p3.copy(age = 23)\n\np1.first should be(__)\np1.last should be(__)\np1.age should be(__)\np1.ssn should be(__)\n\np2.first should be(__)\np2.last should be(__)\np2.age should be(__)\np2.ssn should be(__)\n\np3.first should be(__)\np3.last should be(__)\np3.age should be(__)\np3.ssn should be(__)\n\n(p1 == p4) should be(__)","mode":"scala","solutions":["\"Fred\"","\"Jones\"","23","\"111-22-3333\"","\"Samantha\"","\"Jones\"","0","\"\"","\"Fred\"","\"Jones\"","0","\"111-22-3333\"","true"]},"solution":"\"Fred\",\"Jones\",23,\"111-22-3333\",\"Samantha\",\"Jones\",0,\"\",\"Fred\",\"Jones\",0,\"111-22-3333\",true"},{"id":"koan9","tag":"koan-task","data":{"description":"Case classes can be disassembled to their constituent parts as a tuple","code":"val p1 = Person(\"Fred\", \"Jones\", 23, \"111-22-3333\")\n\nval parts = Person.unapply(p1).get // this seems weird, but it's critical to other features of Scala\n\nparts._1 should be(__)\nparts._2 should be(__)\nparts._3 should be(__)\nparts._4 should be(__)","mode":"scala","solutions":["\"Fred\"","\"Jones\"","23","\"111-22-3333\""]},"solution":"\"Fred\",\"Jones\",23,\"111-22-3333\""}]},{"id": 14, "title": "About Tuples", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Tuples can be created easily","code":"val tuple = (\"apple\", \"dog\")\ntuple should be(__)","mode":"scala","solutions":["(\"apple\", \"dog\")"]},"solution":"(\"apple\", \"dog\")"},{"id":"koan2","tag":"koan-task","data":{"description":"Tuple items may be accessed individually","code":"val tuple = (\"apple\", \"dog\")\nval fruit = tuple._1\nval animal = tuple._2\n\nfruit should be(__)\nanimal should be(__)","mode":"scala","solutions":["\"apple\"","\"dog\""]},"solution":"\"apple\",\"dog\""},{"id":"koan3","tag":"koan-task","data":{"description":"Tuples may be of mixed type","code":"val tuple5 = (\"a\", 1, 2.2, new Date(), BigDecimal(5))\n\ntuple5._2 should be(__)\ntuple5._5 should be(__)","mode":"scala","solutions":["1","BigDecimal(5)"]},"solution":"1,BigDecimal(5)"},{"id":"koan4","tag":"koan-task","data":{"description":"Tuples items can be swapped on a Tuple 2","code":"val tuple = (\"apple\", 3).swap\ntuple._1 should be(__)\ntuple._2 should be(__)","mode":"scala","solutions":["3","\"apple\""]},"solution":"3,\"apple\""}]},{"id": 15, "title": "About Interoperability", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"You can interop with a java class and it's use of collections by importing\n   scala.collection.JavaConversions and letting scala implicitly convert\n   from a Scala collection type\n   into a Java collection type.  See AboutImplicits Koan Suite for more details\n   and see src/test/java for the\n   SomeJavaClass file. This koan\n   converts a scala List of String to java List of raw type.","code":"import de.htwg.scala.koans.SomeJavaClass;\n\n    import scala.collection.JavaConversions._\n    val d = new SomeJavaClass\n    val e = List(\"one\", \"two\", \"three\")\n    d.findSizeOfRawType(e) should be(__)","mode":"scala","solutions":["3"]},"solution":"3"},{"id":"koan2","tag":"koan-task","data":{"description":"This koan converts a scala List of Boat (our own class) to java List of unknown <?> type.","code":"import scala.collection.JavaConversions._\n    val d = new SomeJavaClass\n    val e = List(new Boat(33, \"Skyway\"), new Boat(35, \"New Boat\"))\n    d.findSizeOfUnknownType(e) should be(__)","mode":"scala","solutions":["2"]},"solution":"2"}]},{"id": 16, "title": "About Range", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Range are not inclusive at end of range","code":"val someNumbers = Range(0, 10)\n\nsomeNumbers.size should be(__)","mode":"scala","solutions":["10"]},"solution":"10"},{"id":"koan2","tag":"koan-task","data":{"description":"Range can specify a step for an increment","code":"val someNumbers = Range(2, 10, 3)\n\nsomeNumbers.size should be(__)","mode":"scala","solutions":["3"]},"solution":"3"},{"id":"koan3","tag":"koan-task","data":{"description":"Range doed not include the last item, even in a step increment","code":"val someNumbers = Range(0, 34, 2)\nsomeNumbers.contains(33) should be(__)\nsomeNumbers.contains(32) should be(__)\nsomeNumbers.contains(34) should be(__)","mode":"scala","solutions":["false","true","false"]},"solution":"false,true,false"},{"id":"koan4","tag":"koan-task","data":{"description":"Range can specify to include the last value","code":"val someNumbers = Range(0, 34).inclusive\n\nsomeNumbers.contains(34) should be(__)","mode":"scala","solutions":["true"]},"solution":"true"}]},{"id": 17, "title": "About Recursion", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Methods can be embedded in other methods, this is particularly useful as helper methods for recursion.\n Also in Scala, any recursive method must have a return type.","code":"//Reminder: 5! = 1 x 2 x 3 x 4 x 5 = 120\n\ndef factorial(i: Int): Int = {\n  def fact(i: Int, accumulator: Int): Int = {\n    if (i <= 1)\n      accumulator\n    else\n      fact(i - 1, i * accumulator)\n  }\n  fact(i, 1)\n}\n\nfactorial(0) should be(__)\nfactorial(1) should be(__)\nfactorial(2) should be(__)\nfactorial(3) should be(__)","mode":"scala","solutions":["1","1","2","6"]},"solution":"1,1,2,6"},{"id":"koan2","tag":"koan-task","data":{"description":"As a precaution, the helpful @tailrec annotation will throw a compile time if a method is not tail recursive,\n meaning that the last call and only call of the method is the recursive method. Scala optimizes recursive calls\n to a loop from a stack","code":"//    @tailrec   //Uncomment this like to see the result, then comment it again and answer the koan\n      // could not optimize @tailrec annotated method fibonacci: it contains a recursive call not in tail position fibonacci(n - 1) + fibonacci(n - 2)\n    def fibonacci(n: Int): Int = {\n      if (n <= 1)\n        1\n      else\n        fibonacci(n - 1) + fibonacci(n - 2)\n    }\n\n    //Reminder fibonacci sequence: 1, 1, 2, 3, 5, 8, 13, 21\n    fibonacci(4) should be(__)","mode":"scala","solutions":["5"]},"solution":"5"},{"id":"koan3","tag":"koan-task","data":{"description":"As properly tail recursive method will use an accumulator method so that the only call of a recursive method is the last one.\n just like the first koan above.","code":"def fibonacci(n: Int) = {\n  @tailrec\n  def fib(n: Int, b: Int, a: Int): Int = n match {\n    case 0 => a\n    case _ => fib(n - 1, a + b, b)\n  }\n\n  fib(n, 1, 0)\n}\n\n//Reminder fibonacci sequence: 1, 1, 2, 3, 5, 8, 13, 21\nfibonacci(4) should be(__)","mode":"scala","solutions":["3"]},"solution":"3"}]},{"id": 18, "title": " About Partially  Applied Functions", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"A partially applied function is a function that you do not apply any or all the\n arguments, creating another function. This partially applied function\n doesn't apply any arguments","code":"def sum(a: Int, b: Int, c: Int) = a + b + c\nval sum3 = sum _\nsum3(1, 9, 7) should be(__)\nsum(4, 5, 6) should be(__)","mode":"scala","solutions":["17","15"]},"solution":"17,15"},{"id":"koan2","tag":"koan-task","data":{"description":"Partially applied functions can replace any number of arguments","code":"def sum(a: Int, b: Int, c: Int) = a + b + c\nval sumC = sum(1, 10, _: Int)\nsumC(4) should be(__)\nsum(4, 5, 6) should be(__)","mode":"scala","solutions":["15","15"]},"solution":"15,15"}]},{"id": 19, "title": "About Type Variance", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Using type inference, the type that you instantiate will be the val or var reference type","code":"class MyContainer[A](a: A)(implicit manifest: scala.reflect.Manifest[A]) {\n  private[this] var item = a\n\n  def get = item\n\n  def set(a: A) {\n    item = a\n  }\n\n  def contents = manifest.runtimeClass.getSimpleName\n}\n\nval fruitBasket = new MyContainer(new Orange())\nfruitBasket.contents should be(__)","mode":"scala","solutions":["\"Orange\""]},"solution":"\"Orange\""},{"id":"koan2","tag":"koan-task","data":{"description":"You can explicitly declare the type variable of the object during instantiation","code":"class MyContainer[A](a: A)(implicit manifest: scala.reflect.Manifest[A]) {\n  private[this] var item = a\n\n  def get = item\n\n  def set(a: A) {\n    item = a\n  }\n\n  def contents = manifest.runtimeClass.getSimpleName\n}\n\nval fruitBasket = new MyContainer[Fruit](new Orange())\nfruitBasket.contents should be(__)","mode":"scala","solutions":["\"Fruit\""]},"solution":"\"Fruit\""},{"id":"koan3","tag":"koan-task","data":{"description":"You can coerce your object to a type.","code":"class MyContainer[A](a: A)(implicit manifest: scala.reflect.Manifest[A]) {\n  private[this] var item = a\n\n  def get = item\n\n  def set(a: A) {\n    item = a\n  }\n\n  def contents = manifest.runtimeClass.getSimpleName\n}\n\nval fruitBasket: MyContainer[Fruit] = new MyContainer(new Orange())\nfruitBasket.contents should be(__)","mode":"scala","solutions":["\"Fruit\""]},"solution":"\"Fruit\""},{"id":"koan4","tag":"koan-task","data":{"description":"variable type must match assigned type","code":"class MyContainer[A](a: A)(implicit manifest: scala.reflect.Manifest[A]) {\n  private[this] var item = a\n\n  def get = item\n\n  def set(a: A) {\n    item = a\n  }\n\n  def contents = manifest.runtimeClass.getSimpleName\n}\n\n// Uncomment the following line\n//val fruitBasket: MyContainer[Fruit] = new MyContainer[Orange](new Orange()) // type mismatch - because in the definition A is not covariant so even if Orange <: Fruit, MyContainer[Orange] is not <: MyContainer[Fruit]","mode":"scala","solutions":[]},"solution":""},{"id":"koan5","tag":"koan-task","data":{"description":"covariance lets you specify the container of that type or parent type","code":"class MyContainer[+A](a: A)(implicit manifest: scala.reflect.Manifest[A]) {\n  private[this] val item = a\n\n  def get = item\n\n  def contents = manifest.runtimeClass.getSimpleName\n}\n\nval fruitBasket: MyContainer[Fruit] = new MyContainer[Orange](new Orange())\nfruitBasket.contents should be(__) // Nice, this way we can keep the subtype","mode":"scala","solutions":["\"Orange\""]},"solution":"\"Orange\""},{"id":"koan6","tag":"koan-task","data":{"description":"mutating an object is not allowed with covariance","code":"class MyContainer[+A](a: A)(implicit manifest: scala.reflect.Manifest[A]) {\n  private[this] val item = a\n\n  def get = item\n\n  def contents = manifest.runtimeClass.getSimpleName\n}\n\nval fruitBasket: MyContainer[Fruit] = new MyContainer[Orange](new Orange())\nfruitBasket.contents should be(__)\n\nclass NavelOrange extends Orange //Creating a subtype to prove a point\n// val navelOrangeBasket: MyContainer[NavelOrange] = new MyContainer[Orange](new Orange()) //Bad!\n// val tangeloBasket: MyContainer[Tangelo] = new MyContainer[Orange](new Orange()) //Bad!","mode":"scala","solutions":["\"Orange\""]},"solution":"\"Orange\""},{"id":"koan7","tag":"koan-task","data":{"description":"contravariance is the opposite of covariance","code":"class MyContainer[-A](a: A)(implicit manifest: scala.reflect.Manifest[A]) {\n  private[this] var item = a\n\n  def set(a: A) {\n    item = a\n  }\n\n  def contents = manifest.runtimeClass.getSimpleName\n}\n\nval citrusBasket: MyContainer[Citrus] = new MyContainer[Citrus](new Orange)\ncitrusBasket.contents should be(__)\nval orangeBasket: MyContainer[Orange] = new MyContainer[Citrus](new Tangelo)\norangeBasket.contents should be(__)\nval tangeloBasket: MyContainer[Tangelo] = new MyContainer[Citrus](new Orange)\ntangeloBasket.contents should be(__)\n\nval orangeBasketReally: MyContainer[Orange] = tangeloBasket.asInstanceOf[MyContainer[Orange]]\norangeBasketReally.contents should be(__)\norangeBasketReally.set(new Orange())","mode":"scala","solutions":["\"Citrus\"","\"Citrus\"","\"Citrus\"","\"Citrus\""]},"solution":"\"Citrus\",\"Citrus\",\"Citrus\",\"Citrus\""},{"id":"koan8","tag":"koan-task","data":{"description":"A reference to a parent type means you cannot anticipate getting a more specific type","code":"class MyContainer[-A](a: A)(implicit manifest: scala.reflect.Manifest[A]) {\n  private[this] var item = a\n\n  def set(a: A) {\n    item = a\n  }\n\n  def contents = manifest.runtimeClass.getSimpleName\n}\n\nval citrusBasket: MyContainer[Citrus] = new MyContainer[Citrus](new Orange)\ncitrusBasket.contents should be(__)\nval orangeBasket: MyContainer[Orange] = new MyContainer[Citrus](new Tangelo)\norangeBasket.contents should be(__)\nval tangeloBasket: MyContainer[Tangelo] = new MyContainer[Citrus](new Orange)\ntangeloBasket.contents should be(__)","mode":"scala","solutions":["\"Citrus\"","\"Citrus\"","\"Citrus\""]},"solution":"\"Citrus\",\"Citrus\",\"Citrus\""},{"id":"koan9","tag":"koan-task","data":{"description":"invariance means you need to specify the type exactly","code":"class MyContainer[A](a: A)(implicit manifest: scala.reflect.Manifest[A]) {\n  private[this] var item = a\n\n  def set(a: A) {\n    item = a\n  }\n\n  def get = item\n\n  def contents = manifest.runtimeClass.getSimpleName\n}\n\nval citrusBasket: MyContainer[Citrus] = new MyContainer[Citrus](new Orange)\ncitrusBasket.contents should be(__)","mode":"scala","solutions":["\"Citrus\""]},"solution":"\"Citrus\""},{"id":"koan10","tag":"koan-task","data":{"description":"Declaring a type as invariant also means that you can both mutate and access elements from an object of generic type","code":"class MyContainer[A](a: A)(implicit manifest: scala.reflect.Manifest[A]) {\n  private[this] var item = a\n\n  def set(a: A) {\n    item = a\n  }\n\n  def get = item\n\n  def contents = manifest.runtimeClass.getSimpleName\n}\n\nval citrusBasket: MyContainer[Citrus] = new MyContainer[Citrus](new Orange)\n\ncitrusBasket.set(new Orange)\ncitrusBasket.contents should be(__)\n\ncitrusBasket.set(new Tangelo)\ncitrusBasket.contents should be(__)","mode":"scala","solutions":["\"Citrus\"","\"Citrus\""]},"solution":"\"Citrus\",\"Citrus\""}]},{"id": 20, "title": "About Preconditions", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"On precondition violation, intercept expects type of exception thrown","code":"intercept[IllegalArgumentException] {\n  val myInstance = new WithParameterRequirement(0)\n}\n\nval myInstance = new WithParameterRequirement(\"\")// does not break as we use the alternate constructor which discard the input and set the value 1 anyway","mode":"scala","solutions":[]},"solution":""}]},{"id": 21, "title": "About Type Signatures", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"In Java you declare a generic type within a <>, in Scala it is []","code":"val z: List[String] = \"Do\" :: \"Re\" :: \"Mi\" :: \"Fa\" :: \"So\" :: \"La\" :: \"Te\" :: \"Do\" :: Nil","mode":"scala","solutions":[]},"solution":""},{"id":"koan2","tag":"koan-task","data":{"description":"Most of the time, Scala will infer the type and [] are optional","code":"val z = \"Do\" :: \"Re\" :: \"Mi\" :: \"Fa\" :: \"So\" :: \"La\" :: \"Te\" :: \"Do\" :: Nil //Infers that the list assigned to variable is of type List[String]","mode":"scala","solutions":[]},"solution":""},{"id":"koan3","tag":"koan-task","data":{"description":"A trait can be declared containing a type, where a concrete implementer will satisfy the type","code":"trait Randomizer[A] {\n  def draw(): A\n}\n\nclass IntRandomizer extends Randomizer[Int] {\n  def draw() = {\n    import util.Random\n    Random.nextInt()\n  }\n}\n\nval intRand = new IntRandomizer\n(intRand.draw < Int.MaxValue) should be (__)","mode":"scala","solutions":["__"]},"solution":"__"},{"id":"koan4","tag":"koan-task","data":{"description":"Class meta-information can be retrieved by class name by using classOf[className]","code":"classOf[String].getCanonicalName should be(__)\nclassOf[String].getSimpleName should be(__)","mode":"scala","solutions":["\"java.lang.String\"","\"String\""]},"solution":"\"java.lang.String\",\"String\""},{"id":"koan5","tag":"koan-task","data":{"description":"Class meta-information can be derived from an object reference using getClass()","code":"val zoom = \"zoom\"\nzoom.getClass should be(__) // Hint: classOf ...\nzoom.getClass.getCanonicalName should be(__)\nzoom.getClass.getSimpleName should be(__)","mode":"scala","solutions":["classOf[String]","\"java.lang.String\"","\"String\""]},"solution":"classOf[String],\"java.lang.String\",\"String\""},{"id":"koan6","tag":"koan-task","data":{"description":"isInstanceOf[className] is used to determine the if an object reference is an instance of given class","code":"trait Randomizer[A] {\n  def draw(): A\n}\n\nclass IntRandomizer extends Randomizer[Int] {\n  def draw() = {\n    import util.Random\n    Random.nextInt()\n  }\n}\n\nval intRand = new IntRandomizer\nintRand.draw.isInstanceOf[Int] should be(__)","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan7","tag":"koan-task","data":{"description":"asInstanceOf[className] is used to cast one reference to another","code":"trait Randomizer[A] {\n  def draw(): A\n}\n\nclass IntRandomizer extends Randomizer[Int] {\n  def draw = {\n    import util.Random\n    Random.nextInt()\n  }\n}\n\nval intRand = new IntRandomizer\nval rand = intRand\nval intRand2 = rand\nintRand2.isInstanceOf[IntRandomizer] should be(__)","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan8","tag":"koan-task","data":{"description":"null.asInstanceOf[className] can be used to generate basic default values","code":"null.asInstanceOf[String] should be(__)\n   // null.asInstanceOf[Int] should be(__)\n   // null.asInstanceOf[Short] should be(__)","mode":"scala","solutions":["null","0","0"]},"solution":"null,0,0"}]},{"id": 22, "title": "  About Named   And Default   Arguments", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"can specify arguments in any order if you use their names","code":"val me = new WithoutClassParameters()\n\n// what happens if you change the order of these parameters (nothing)\nval myColor = me.addColors(green = 0, red = 255, blue = 0)\n\n// for koan, remove the values in the should equal\nmyColor should equal(__)","mode":"scala","solutions":["255, 0, 0"]},"solution":"255, 0, 0"},{"id":"koan2","tag":"koan-task","data":{"description":"can default arguments if you leave them off","code":"val me = new WithoutClassParameters()\nval myColor = me.addColorsWithDefaults(green = 255)\n\nmyColor should equal(__)","mode":"scala","solutions":["0, 255, 0"]},"solution":"0, 255, 0"},{"id":"koan3","tag":"koan-task","data":{"description":"can access class parameters and specify arguments in any order if you use their names","code":"val me = new WithClassParameters(40, 50, 60)\nval myColor = me.addColors(green = 50, red = 60, blue = 40)\n\nmyColor should equal(__)","mode":"scala","solutions":["100, 100, 100"]},"solution":"100, 100, 100"},{"id":"koan4","tag":"koan-task","data":{"description":"can access class parameters and default arguments if you leave them off","code":"val me = new WithClassParameters(10, 20, 30)\nval myColor = me.addColorsWithDefaults(green = 70)\n\nmyColor should equal(__)","mode":"scala","solutions":["10, 90, 30"]},"solution":"10, 90, 30"},{"id":"koan5","tag":"koan-task","data":{"description":"can default class parameters and have default arguments too","code":"val me = new WithClassParametersInClassDefinition()\nval myColor = me.addColorsWithDefaults(green = 70)\n\nmyColor should equal(__)","mode":"scala","solutions":["0, 325, 100"]},"solution":"0, 325, 100"},{"id":"koan6","tag":"koan-task","data":{"description":"default parameters can be functional too","code":"def reduce(a: Int, f: (Int, Int) => Int = (_ + _)): Int = f(a, a)\n\nreduce(5) should equal(__)\nreduce(5, _ * _) should equal(__)","mode":"scala","solutions":["10","25"]},"solution":"10,25"}]},{"id": 23, "title": "About Manifests", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Manifests can be used to determine a type used\n   before it erased by the VM by using an implicit manifest argument.","code":"def inspect[T](l: List[T])(implicit manifest: scala.reflect.Manifest[T]) = manifest.toString\nval list = 1 :: 2 :: 3 :: 4 :: 5 :: Nil\ninspect(list) should be(__)","mode":"scala","solutions":["\"Int\""]},"solution":"\"Int\""},{"id":"koan2","tag":"koan-task","data":{"description":"Manifests can be attached to classes. Manifests have other meta-information about\n  the type erased","code":"class Barrel[T](implicit m: scala.reflect.Manifest[T]) {\n  def +(t: T) = \"1 %s has been added\".format(m.runtimeClass.getSimpleName) //Simple-name of the class erased\n}\nval monkeyBarrel = new Barrel[Monkey]\n(monkeyBarrel + new Monkey) should be(__)","mode":"scala","solutions":["\"1 Monkey has been added\""]},"solution":"\"1 Monkey has been added\""}]},{"id": 24, "title": " About Infix  Prefix  And  Postfix Operators", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Simple: Infix Operators are available if an object\n  has a method that takes one parameter.","code":"val g: Int = 3\n(g + 4) should be(__) // + is an infix operator\n g.+(4) should be(__) // same result but not using the infix operator","mode":"scala","solutions":["7","7"]},"solution":"7,7"},{"id":"koan2","tag":"koan-task","data":{"description":"Infix Operators do NOT work if an object\n  has a method that takes two parameters.","code":"val g: String = \"Check out the big brains on Brad!\"\ng indexOf 'o' should be(__) can be used as an infix operator\n//g indexOf 'o', 4 should be (__) cannot be used an infix operator\ng.indexOf('o', 7) should be(__) must use standard java/scala calls","mode":"scala","solutions":["6) //indexOf(Char","6) //indexOf(Char, Int","25) //indexOf(Char, Int"]},"solution":"6) //indexOf(Char,6) //indexOf(Char, Int,25) //indexOf(Char, Int"},{"id":"koan3","tag":"koan-task","data":{"description":"Postfix operators work if an object\n  has a method that takes no parameters.","code":"val g: Int = 31\n(g toHexString) should be(__) //toHexString takes no params therefore can be called\n//as a postfix operator. Hint: The answer is 1f","mode":"scala","solutions":["\"1f\""]},"solution":"\"1f\""},{"id":"koan4","tag":"koan-task","data":{"description":"Prefix operators work if an object\n  has a method name that starts with unary_ .","code":"val g: Int = 31\n(-g) should be(__)","mode":"scala","solutions":["-31"]},"solution":"-31"},{"id":"koan5","tag":"koan-task","data":{"description":"Here we create our own prefix operator for our own class.\n   The only identifiers that can be used as prefix operators\n   are +, -, !, and ~","code":"class Stereo {\n  def unary_+ = \"on\"\n\n  def unary_- = \"off\"\n}\n\nval stereo = new Stereo\n(+stereo) should be(__)\n(-stereo) should be(__)","mode":"scala","solutions":["\"on\"","\"off\""]},"solution":"\"on\",\"off\""}]},{"id": 25, "title": "About Implicits", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Implicits wrap around existing classes to provide extra functionality\n   This is similar to \\'monkey patching\\' in Ruby, and Meta-Programming in Groovy.\n   Creating a method isOdd for Int, which doesn't exist","code":"class KoanIntWrapper(val original: Int) {\n  def isOdd = original % 2 != 0\n}\n\nimplicit def thisMethodNameIsIrrelevant(value: Int) = new KoanIntWrapper(value)\n\n19.isOdd should be(__)\n20.isOdd should be(__)","mode":"scala","solutions":["true","false"]},"solution":"true,false"},{"id":"koan2","tag":"koan-task","data":{"description":"Implicits rules can be imported into your scope with an import","code":"object MyPredef {\n\n  class KoanIntWrapper(val original: Int) {\n    def isOdd = original % 2 != 0\n\n    def isEven = !isOdd\n  }\n\n  implicit def thisMethodNameIsIrrelevant(value: Int) = new KoanIntWrapper(value)\n}\n\nimport MyPredef._\n//imported implicits come into effect within this scope\n19.isOdd should be(__)\n20.isOdd should be(__)","mode":"scala","solutions":["true","false"]},"solution":"true,false"},{"id":"koan3","tag":"koan-task","data":{"description":"Implicits can be used to automatically convert one type to another","code":"import java.math.BigInteger\nimplicit def Int2BigIntegerConvert(value: Int): BigInteger = new BigInteger(value.toString)\n\ndef add(a: BigInteger, b: BigInteger) = a.add(b)\n\nadd(3, 6) should be(__)","mode":"scala","solutions":["Int2BigIntegerConvert(9)"]},"solution":"Int2BigIntegerConvert(9)"},{"id":"koan4","tag":"koan-task","data":{"description":"Implicits can be used to declare a value to be provided as a default as\n   long as an implicit value is set with in the scope.  These are\n   called implicit function parameters","code":"def howMuchCanIMake_?(hours: Int)(implicit dollarsPerHour: BigDecimal) = dollarsPerHour * hours\n\nimplicit var hourlyRate = BigDecimal(34.00)\n\nhowMuchCanIMake_?(30) should be(__)\n\nhourlyRate = BigDecimal(95.00)\nhowMuchCanIMake_?(95) should be(__)","mode":"scala","solutions":["1020","9025"]},"solution":"1020,9025"},{"id":"koan5","tag":"koan-task","data":{"description":"Implicit Function Parameters can contain a list of implicits","code":"def howMuchCanIMake_?(hours: Int)(implicit amount: BigDecimal, currencyName: String) =\n  (amount * hours).toString() + \" \" + currencyName\n\nimplicit var hourlyRate = BigDecimal(34.00)\nimplicit val currencyName = \"Dollars\"\n\nhowMuchCanIMake_?(30) should be(__)\n\nhourlyRate = BigDecimal(95.00)\nhowMuchCanIMake_?(95) should be(__)","mode":"scala","solutions":["\"1020.0 Dollars\"","\"9025.0 Dollars\""]},"solution":"\"1020.0 Dollars\",\"9025.0 Dollars\""},{"id":"koan6","tag":"koan-task","data":{"description":"Default arguments though are preferred to Implicit Function Parameters","code":"def howMuchCanIMake_?(hours: Int, amount: BigDecimal = 34, currencyName: String = \"Dollars\") =\n  (amount * hours).toString() + \" \" + currencyName\n\nhowMuchCanIMake_?(30) should be(__)\n\nhowMuchCanIMake_?(95, 95) should be(__)","mode":"scala","solutions":["\"1020 Dollars\"","\"9025 Dollars\""]},"solution":"\"1020 Dollars\",\"9025 Dollars\""}]},{"id": 26, "title": "About Classes", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"val parameters in class definition define getter","code":"val aClass = new ClassWithValParameter(\"name goes here\")\naClass.name should be(__)","mode":"scala","solutions":["\"name goes here\""]},"solution":"\"name goes here\""},{"id":"koan2","tag":"koan-task","data":{"description":"var parameters in class definition define getter and setter","code":"val aClass = new ClassWithVarParameter(\"description goes here\")\naClass.description should be(__)\n\naClass.description = \"new description\"\naClass.description should be(__)","mode":"scala","solutions":["\"description goes here\"","\"new description\""]},"solution":"\"description goes here\",\"new description\""},{"id":"koan3","tag":"koan-task","data":{"description":"fields defined internally are private to class","code":"val aClass = new ClassWithPrivateFields(\"name\")\n\n// NOTE: aClass.name is not accessible","mode":"scala","solutions":[]},"solution":""}]},{"id": 27, "title": "About Higher Order Functions", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Meet lambda. Anonymous function","code":"def lambda = { x: Int => x + 1 }\ndef lambda2 = (x:Int) => x + 1\nval lambda3 = (x:Int) => x + 1\n\nval lambda4 = new Function1[Int, Int] {\n  def apply(v1: Int): Int = v1 + 1\n}\n\ndef lambda5(x:Int) = x + 1\n\nval result = lambda(3)\nval `result1andhalf` = lambda.apply(3)\n\nval result2 = lambda2(3)\nval result3 = lambda3(3)\nval result4 = lambda4(3)\nval result5 = lambda5(3)\n\nresult should be(__)\nresult1andhalf should be(__)\nresult2 should be(__)\nresult3 should be(__)\nresult4 should be(__)\nresult5 should be(__)","mode":"scala","solutions":["4","4","4","4","4","4"]},"solution":"4,4,4,4,4,4"},{"id":"koan2","tag":"koan-task","data":{"description":"An anonymous function can also take on a different look by taking out the brackets","code":"def lambda = (x: Int) => x + 1\ndef result = lambda(5)\nresult should be(__)","mode":"scala","solutions":["6"]},"solution":"6"},{"id":"koan3","tag":"koan-task","data":{"description":"Meet closure. Closure is any function that closes over the environment","code":"var incrementer = 1\n\ndef closure = {\n  x: Int => x + incrementer\n}\n\nval result1 = closure(10)\nresult1 should be(__)\n\nincrementer = 2\n\nval result2 = closure(10)\nresult2 should be(__)","mode":"scala","solutions":["11","12"]},"solution":"11,12"},{"id":"koan4","tag":"koan-task","data":{"description":"We can take that closure and throw into a method and it will still hold the environment","code":"def summation(x:Int, y: Int => Int) = y(x)\n\nvar incrementer = 1\ndef closure = (x: Int) => x + incrementer\n\nval result = summation(10, closure)\nresult should be(__)\n\nincrementer = 3\nval result2 = summation(10, closure)\nresult2 should be(__)","mode":"scala","solutions":["11","13"]},"solution":"11,13"},{"id":"koan5","tag":"koan-task","data":{"description":"function returning another function","code":"def addWithoutSyntaxSugar(x: Int) = {\n  new Function1[Int, Int]() {\n    def apply(y: Int): Int = x + y\n  }\n}\naddWithoutSyntaxSugar(1).\n  isInstanceOf[Function1[Int,Int]] should be(__)\n\naddWithoutSyntaxSugar(2)(3) should be(__)\n\ndef fiveAdder = addWithoutSyntaxSugar(5)\nfiveAdder(5) should be(__)","mode":"scala","solutions":["true","5","10"]},"solution":"true,5,10"},{"id":"koan6","tag":"koan-task","data":{"description":"isInstanceOf is the same as instanceof in java, but in this case the parameter types can be\n 'blanked out' using existential types with is a single underline, since parameter type are unknown\n at runtime.","code":"def addWithSyntaxSugar(x: Int) = (y:Int) => x + y\n\naddWithSyntaxSugar(1).isInstanceOf[Function1[Int, Int]] should be(__)","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan7","tag":"koan-task","data":{"description":"function taking another function as parameter. Helps in composing functions.\n Hint: a map method applies the function to each element of a list","code":"def makeUpper(xs: List[String]) = xs map {_.toUpperCase}\n\ndef makeWhatEverYouLike(xs: List[String], sideEffect: String => String) = {\n  xs map sideEffect\n}\n\nmakeUpper(List(\"abc\", \"xyz\", \"123\")) should be(__)\n\nmakeWhatEverYouLike(List(\"ABC\", \"XYZ\", \"123\"), {\n  x => x.toLowerCase\n}) should be(__)\n\n//using it inline\nList(\"Scala\", \"Erlang\", \"Clojure\") map {_.length} should be(__)","mode":"scala","solutions":["List(\"ABC\", \"XYZ\", \"123\")","List(\"abc\", \"xyz\", \"123\")","List(5, 6, 7)"]},"solution":"List(\"ABC\", \"XYZ\", \"123\"),List(\"abc\", \"xyz\", \"123\"),List(5, 6, 7)"},{"id":"koan8","tag":"koan-task","data":{"description":"Currying is a technique to transform function with multiple parameters to function with one parameter","code":"def multiply(x: Int, y: Int) = x * y\n(multiply _).isInstanceOf[Function2[_, _, _]] should be(__)\nval multiplyCurried = (multiply _).curried\nmultiply(4, 5) should be(__)\nmultiplyCurried(3)(2) should be(__)","mode":"scala","solutions":["true","20","6"]},"solution":"true,20,6"},{"id":"koan9","tag":"koan-task","data":{"description":"Currying allows you to create specialized version of generalized function","code":"def customFilter(f: Int => Boolean)(xs: List[Int]) = {\n  xs filter f\n}\ndef onlyEven(x: Int) = x % 2 == 0\nval xs = List(12, 11, 5, 20, 3, 13, 2)\ncustomFilter(onlyEven)(xs) should be(__)\n\nval onlyEvenFilter = customFilter(onlyEven) _\nonlyEvenFilter(xs) should be(__)","mode":"scala","solutions":["List(12, 20, 2)","List(12, 20, 2)"]},"solution":"List(12, 20, 2),List(12, 20, 2)"}]},{"id": 28, "title": "About Repeated Parameters", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"A repeated parameter can accept a collection as the last parameter but will be considered a single object","code":"repeatedParameterMethod(3, \"egg\", List(\"a delicious sandwich\", \"protein\", \"high cholesterol\")) should be(__)","mode":"scala","solutions":["\"3 eggs can give you List(a delicious sandwich, protein, high cholesterol)\""]},"solution":"\"3 eggs can give you List(a delicious sandwich, protein, high cholesterol)\""},{"id":"koan2","tag":"koan-task","data":{"description":"A repeated parameter can accept a collection, and if you want it expanded, add :_*","code":"repeatedParameterMethod(3, \"egg\", List(\"a delicious sandwich\", \"protein\", \"high cholesterol\"):_*) should be(__)","mode":"scala","solutions":["\"3 eggs can give you a delicious sandwich, protein, high cholesterol\""]},"solution":"\"3 eggs can give you a delicious sandwich, protein, high cholesterol\""}]},{"id": 29, "title": "About Lists", "tasks": [{"id":"video1","tag":"video-task","data":{"description":"Video zu Scala Listen","url":"gi6HWvtzd8E"},"solution":"watched"},{"id":"koan1","tag":"koan-task","data":{"description":"Listen Kopf","code":"val list = List(10, 20, 30)\nlist.head should be(__)","mode":"scala","solutions":["10"]},"solution":"10"},{"id":"code1","tag":"code-task","data":{"description":"Implementieren sie die Funktion addOne","code":"// addOne soll 1 zu jedem element in einer Liste addieren\ndef addOne(l: List[Int]): List[Int] = {\n  //todo\n}","mode":"scala"},"solution":"assert(addOne(List(1, 2)) == List(2, 3))"}]},{"id": 30, "title": "About Parent Classes", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Class hierarchy is linear, a class can only extend from one parent class","code":"class Worker(val firstName: String, val lastName: String) {}\nclass Employee(override val firstName: String, override val lastName: String,\n               val employeeID: Long) extends Worker(firstName, lastName)\n\nval me = new Employee(\"Name\", \"Yourself\", 1233)\nme.firstName should be(__)\nme.lastName should be(__)","mode":"scala","solutions":["\"Name\"","\"Yourself\""]},"solution":"\"Name\",\"Yourself\""},{"id":"koan2","tag":"koan-task","data":{"description":"A class that extends from another is polymorphic","code":"class Worker(val firstName: String, val lastName: String) {}\nclass Employee(override val firstName: String, override val lastName: String,\n               val employeeID: Long) extends Worker(firstName, lastName)\n\nval me = new Employee(\"Name\", \"Yourself\", 1233)\nval worker: Worker = me\n\nworker.firstName should be(__)\nworker.lastName should be(__)","mode":"scala","solutions":["\"Name\"","\"Yourself\""]},"solution":"\"Name\",\"Yourself\""},{"id":"koan3","tag":"koan-task","data":{"description":"An abstract class, as in Java, cannot be instantiated and only inherited","code":"abstract class Worker(val firstName: String, val lastName: String) {}\n\n// if you uncomment this line, if will fail compilation\n//val worker = new Worker // class Worker is abstract; cannot be instantiated","mode":"scala","solutions":[]},"solution":""},{"id":"koan4","tag":"koan-task","data":{"description":"A class can be placed inside an abstract class just like in java","code":"abstract class Worker(val firstName: String, val lastName: String) {\n  class Assignment(val hours: Long) {\n    // nothing to do here.  Just observe that it compiles\n  }\n}\nclass Employee(override val firstName: String, override val lastName: String,\n               val employeeID: Long) extends Worker(firstName, lastName)\n\nval employee = new Employee(\"Name\", \"Yourself\", 2291)\nval assignment = new employee.Assignment(22)  //using the employee instance's path, create an assignment for it.\nassignment.hours should be (__)","mode":"scala","solutions":["22"]},"solution":"22"}]},{"id": 31, "title": "About Enumerations", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Value assigns a numerical value to fields","code":"object Planets extends Enumeration {\n  val Mercury = Value\n  val Venus = Value\n  val Earth = Value\n  val Mars = Value\n  val Jupiter = Value\n  val Saturn = Value\n  val Uranus = Value\n  val Neptune = Value\n  val Pluto = Value\n}\n\nPlanets.Mercury.id should be(__)\nPlanets.Venus.id should be(__)\n\nPlanets.Mercury.toString should be(__) //How does it get the name? by Reflection.\nPlanets.Venus.toString should be(__)\n\n(Planets.Earth == Planets.Earth) should be(__)\n(Planets.Neptune == Planets.Jupiter) should be(__)","mode":"scala","solutions":["0","1","\"Mercury\"","\"Venus\"","true","false"]},"solution":"0,1,\"Mercury\",\"Venus\",true,false"},{"id":"koan2","tag":"koan-task","data":{"description":"Enumerations can set their own index and name","code":"object GreekPlanets extends Enumeration {\n\n  val Mercury = Value(1, \"Hermes\")\n  val Venus = Value(2, \"Aphrodite\")\n  //Fun Fact: Tellus is Roman for (Mother) Earth\n  val Earth = Value(3, \"Gaia\")\n  val Mars = Value(4, \"Ares\")\n  val Jupiter = Value(5, \"Zeus\")\n  val Saturn = Value(6, \"Cronus\")\n  val Uranus = Value(7, \"Ouranus\")\n  val Neptune = Value(8, \"Poseidon\")\n  val Pluto = Value(9, \"Hades\")\n}\n\nGreekPlanets.Mercury.id should be(__)\nGreekPlanets.Venus.id should be(__)\n\nGreekPlanets.Mercury.toString should be(__)\nGreekPlanets.Venus.toString should be(__)\n\n(GreekPlanets.Earth == GreekPlanets.Earth) should be(__)\n(GreekPlanets.Neptune == GreekPlanets.Jupiter) should be(__)","mode":"scala","solutions":["1","2","\"Hermes\"","\"Aphrodite\"","true","false"]},"solution":"1,2,\"Hermes\",\"Aphrodite\",true,false"},{"id":"koan3","tag":"koan-task","data":{"description":"Enumeration declarations can be done on one line","code":"object Planets extends Enumeration {\n  val Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune, Pluto = Value\n}\n\nPlanets.Mercury.id should be(__)\nPlanets.Venus.id should be(__)\n\nPlanets.Mercury.toString should be(__)\nPlanets.Venus.toString should be(__)\n\n(Planets.Earth == Planets.Earth) should be(__)\n(Planets.Neptune == Planets.Jupiter) should be(__)","mode":"scala","solutions":["0","1","\"Mercury\"","\"Venus\"","true","false"]},"solution":"0,1,\"Mercury\",\"Venus\",true,false"},{"id":"koan4","tag":"koan-task","data":{"description":"Enumerations can be declared with a string value only","code":"object GreekPlanets extends Enumeration {\n\n  val Mercury = Value(\"Hermes\")\n  val Venus = Value(\"Aphrodite\")\n  val Earth = Value(\"Gaia\")\n  val Mars = Value(\"Ares\")\n  val Jupiter = Value(\"Zeus\")\n  val Saturn = Value(\"Cronus\")\n  val Uranus = Value(\"Ouranus\")\n  val Neptune = Value(\"Poseidon\")\n  val Pluto = Value(\"Hades\")\n}\n\nGreekPlanets.Mercury.id should be(__)\nGreekPlanets.Venus.id should be(__)\n\nGreekPlanets.Mercury.toString should be(__)\nGreekPlanets.Venus.toString should be(__)\n\n(GreekPlanets.Earth == GreekPlanets.Earth) should be(__)\n(GreekPlanets.Neptune == GreekPlanets.Jupiter) should be(__)","mode":"scala","solutions":["0","1","\"Hermes\"","\"Aphrodite\"","true","false"]},"solution":"0,1,\"Hermes\",\"Aphrodite\",true,false"},{"id":"koan5","tag":"koan-task","data":{"description":"You can extend the Enumeration by extending the Val class.","code":"object Planets extends Enumeration {\n\n  val G = 6.67300E-11\n\n  class PlanetValue(val i: Int, val name: String, val mass: Double, val radius: Double)\n          extends Val(i: Int, name: String) {\n\n    def surfaceGravity = G * mass / (radius * radius)\n\n    def surfaceWeight(otherMass: Double) = otherMass * surfaceGravity\n\n    def compare(that: PlanetValue) = this.i - that.i\n  }\n\n  val Mercury = new PlanetValue(0, \"Mercury\", 3.303e+23, 2.4397e6)\n  val Venus = new PlanetValue(1, \"Venus\", 4.869e+24, 6.0518e6)\n  val Earth = new PlanetValue(2, \"Earth\", 5.976e+24, 6.37814e6)\n  val Mars = new PlanetValue(3, \"Mars\", 6.421e+23, 3.3972e6)\n  val Jupiter = new PlanetValue(4, \"Jupiter\", 1.9e+27, 7.1492e7)\n  val Saturn = new PlanetValue(5, \"Saturn\", 5.688e+26, 6.0268e7)\n  val Uranus = new PlanetValue(6, \"Uranus\", 8.686e+25, 2.5559e7)\n  val Neptune = new PlanetValue(7, \"Neptune\", 1.024e+26, 2.4746e7)\n  val Pluto = new PlanetValue(8, \"Pluto\", 1.27e+22, 1.137e6)\n\n}\n\nPlanets.Earth.mass should be(__)\nPlanets.Earth.radius should be(__)","mode":"scala","solutions":["5.976e+24","6.37814e6"]},"solution":"5.976e+24,6.37814e6"}]},{"id": 32, "title": "About Infix Types", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"We can make a type infix, meaning that the type can be displayed in complement\n           between two types in order to make a readable delaration","code":"case class Person(name: String)\nclass Loves[A, B](val a: A, val b: B)\n\ndef announceCouple(couple: Person Loves Person) = {\n  //Notice our type: Person loves Person!\n  couple.a.name + \" is in love with \" + couple.b.name\n}\n\nval romeo = new Person(\"Romeo\")\nval juliet = new Person(\"Juliet\")\n\nannounceCouple(new Loves(romeo, juliet)) should be(__)","mode":"scala","solutions":["\"Romeo is in love with Juliet\""]},"solution":"\"Romeo is in love with Juliet\""},{"id":"koan2","tag":"koan-task","data":{"description":"Of course we can make this a bit more elegant by creating an infix operator\n  method to use with our infix type","code":"case class Person(name: String) {\n  def loves(person: Person) = new Loves(this, person)\n}\n\nclass Loves[A, B](val a: A, val b: B)\n\ndef announceCouple(couple: Person Loves Person) = {\n  //Notice our type: Person loves Person!\n  couple.a.name + \" is in love with \" + couple.b.name\n}\n\nval romeo = new Person(\"Romeo\")\nval juliet = new Person(\"Juliet\")\n\nannounceCouple(romeo loves juliet) should be(__)","mode":"scala","solutions":["\"Romeo is in love with Juliet\""]},"solution":"\"Romeo is in love with Juliet\""}]},{"id": 33, "title": "Koans", "tasks": []},{"id": 34, "title": "  About Sequences   And   Arrays", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"A list can be converted to an array","code":"val l = List(1, 2, 3)\nval a = l.toArray\na should equal(__)","mode":"scala","solutions":["Array(1, 2, 3)"]},"solution":"Array(1, 2, 3)"},{"id":"koan2","tag":"koan-task","data":{"description":"Any sequence can be converted to a list","code":"val a = Array(1, 2, 3)\nval s = a.toSeq\nval l = s.toList\nl should equal(__)","mode":"scala","solutions":["List(1, 2, 3)"]},"solution":"List(1, 2, 3)"},{"id":"koan3","tag":"koan-task","data":{"description":"You can create a sequence from a for comprehension","code":"val s = for (v <- 1 to 4) yield v\ns.toList should be(__)","mode":"scala","solutions":["List(1, 2, 3, 4)"]},"solution":"List(1, 2, 3, 4)"},{"id":"koan4","tag":"koan-task","data":{"description":"You can create a sequence from a for comprehension with a condition","code":"val s = for (v <- 1 to 10 if v % 3 == 0) yield v\ns.toList should be(__)","mode":"scala","solutions":["List(3, 6, 9)"]},"solution":"List(3, 6, 9)"},{"id":"koan5","tag":"koan-task","data":{"description":"You can filter any sequence based on a predicate","code":"val s = Seq(\"hello\", \"to\", \"you\")\nval filtered = s.filter(_.length > 2)\nfiltered should be(__)","mode":"scala","solutions":["Seq(\"hello\", \"you\")"]},"solution":"Seq(\"hello\", \"you\")"},{"id":"koan6","tag":"koan-task","data":{"description":"You can also filter Arrays in the same way","code":"val a = Array(\"hello\", \"to\", \"you\", \"again\")\nval filtered = a.filter(_.length > 3)\nfiltered should be(__)","mode":"scala","solutions":["Array(\"hello\", \"again\")"]},"solution":"Array(\"hello\", \"again\")"},{"id":"koan7","tag":"koan-task","data":{"description":"You can map values in a sequence through a function","code":"val s = Seq(\"hello\", \"world\")\nval r = s map {\n  _.reverse\n}\n\nr should be(__)","mode":"scala","solutions":["Seq(\"olleh\", \"dlrow\")"]},"solution":"Seq(\"olleh\", \"dlrow\")"}]},{"id": 35, "title": "About Maps", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Maps can be created easily","code":"val myMap = Map(\"MI\" -> \"Michigan\", \"OH\" -> \"Ohio\", \"WI\" -> \"Wisconsin\", \"IA\" -> \"Iowa\")\nmyMap.size should be(__)","mode":"scala","solutions":["4"]},"solution":"4"},{"id":"koan2","tag":"koan-task","data":{"description":"Maps contain distinct pairings","code":"val myMap = Map(\"MI\" -> \"Michigan\", \"OH\" -> \"Ohio\", \"WI\" -> \"Wisconsin\", \"MI\" -> \"Michigan\")\nmyMap.size should be(__)","mode":"scala","solutions":["3"]},"solution":"3"},{"id":"koan3","tag":"koan-task","data":{"description":"Maps can be added to easily","code":"val myMap = Map(\"MI\" -> \"Michigan\", \"OH\" -> \"Ohio\", \"WI\" -> \"Wisconsin\", \"MI\" -> \"Michigan\")\n\nval aNewMap = myMap + (\"IL\" -> \"Illinois\")\n\naNewMap.contains(\"IL\") should be(__)","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan4","tag":"koan-task","data":{"description":"Map values can be iterated","code":"val myMap = Map(\"MI\" -> \"Michigan\", \"OH\" -> \"Ohio\", \"WI\" -> \"Wisconsin\", \"MI\" -> \"Michigan\")\n\nval mapValues = myMap.values\n\nmapValues.size should be(__)\n\nmapValues.head should be(__)\n\nval lastElement = mapValues.last\nlastElement should be(__)\n\n// for (mval <- mapValues) println(mval)\n\n// NOTE that the following will not compile, as iterators do not implement \"contains\"\n//mapValues.contains(\"Illinois\") should be (__)","mode":"scala","solutions":["3","\"Michigan\"","\"Wisconsin\"","true"]},"solution":"3,\"Michigan\",\"Wisconsin\",true"},{"id":"koan5","tag":"koan-task","data":{"description":"Maps insertion with duplicate key updates previous entry with subsequent value","code":"val myMap = Map(\"MI\" -> \"Michigan\", \"OH\" -> \"Ohio\", \"WI\" -> \"Wisconsin\", \"MI\" -> \"Meechigan\")\n\nval mapValues = myMap.values\n\nmapValues.size should be(__)\n\nmyMap(\"MI\") should be(__)","mode":"scala","solutions":["3","\"Meechigan\""]},"solution":"3,\"Meechigan\""},{"id":"koan6","tag":"koan-task","data":{"description":"Map keys may be of mixed type","code":"val myMap = Map(\"Ann Arbor\" -> \"MI\", 49931 -> \"MI\")\nmyMap(\"Ann Arbor\") should be(__)\nmyMap(49931) should be(__)","mode":"scala","solutions":["\"MI\"","\"MI\""]},"solution":"\"MI\",\"MI\""},{"id":"koan7","tag":"koan-task","data":{"description":"Mixed type values can be added to a map ","code":"val myMap = scala.collection.mutable.Map.empty[String, Any]\nmyMap(\"Ann Arbor\") = (48103, 48104, 48108)\nmyMap(\"Houghton\") = 49931\n\nmyMap(\"Houghton\") should be(__)\nmyMap(\"Ann Arbor\") should be(__)\n\n// what happens if you change the Any to Int\n// the entry Ann Arbor does not compile anymore as this is a List[Int] type and not Int","mode":"scala","solutions":["49931","(48103, 48104, 48108)"]},"solution":"49931,(48103, 48104, 48108)"},{"id":"koan8","tag":"koan-task","data":{"description":"Maps may be accessed","code":"val myMap = Map(\"MI\" -> \"Michigan\", \"OH\" -> \"Ohio\", \"WI\" -> \"Wisconsin\", \"IA\" -> \"Iowa\")\nmyMap(\"MI\") should be(__)\nmyMap(\"IA\") should be(__)","mode":"scala","solutions":["\"Michigan\"","\"Iowa\""]},"solution":"\"Michigan\",\"Iowa\""},{"id":"koan9","tag":"koan-task","data":{"description":"Map elements can be removed easily","code":"val myMap = Map(\"MI\" -> \"Michigan\", \"OH\" -> \"Ohio\", \"WI\" -> \"Wisconsin\", \"IA\" -> \"Iowa\")\nval aNewMap = myMap - \"MI\"\naNewMap.contains(\"MI\") should be(__)","mode":"scala","solutions":["false"]},"solution":"false"},{"id":"koan10","tag":"koan-task","data":{"description":"Accessing a map by key results in an exception if key is not found","code":"val myMap = Map(\"OH\" -> \"Ohio\", \"WI\" -> \"Wisconsin\", \"IA\" -> \"Iowa\")\n\n// Cheat Code (because this is hard to illustrate): uncomment the intercept code to make this pass\nintercept[NoSuchElementException] {\n  myMap(\"MI\") should be(__)\n}","mode":"scala","solutions":["Nil"]},"solution":"Nil"},{"id":"koan11","tag":"koan-task","data":{"description":"Map elements can be removed in multiple","code":"val myMap = Map(\"MI\" -> \"Michigan\", \"OH\" -> \"Ohio\", \"WI\" -> \"Wisconsin\", \"IA\" -> \"Iowa\")\n\nval aNewMap = myMap -- List(\"MI\", \"OH\")\n\naNewMap.contains(\"MI\") should be(__)\n\naNewMap.contains(\"WI\") should be(__)\naNewMap.size should be(__)","mode":"scala","solutions":["false","true","2"]},"solution":"false,true,2"},{"id":"koan12","tag":"koan-task","data":{"description":"Map elements can be removed with a tuple","code":"val myMap = Map(\"MI\" -> \"Michigan\", \"OH\" -> \"Ohio\", \"WI\" -> \"Wisconsin\", \"IA\" -> \"Iowa\")\nval aNewMap = myMap - (\"MI\", \"WI\") // Notice: single '-' operator for tuples\n\naNewMap.contains(\"MI\") should be(__)\naNewMap.contains(\"OH\") should be(__)\naNewMap.size should be(__)","mode":"scala","solutions":["false","true","2"]},"solution":"false,true,2"},{"id":"koan13","tag":"koan-task","data":{"description":"Attempted removal of nonexistent elements from a map is handled gracefully","code":"val myMap = Map(\"MI\" -> \"Michigan\", \"OH\" -> \"Ohio\", \"WI\" -> \"Wisconsin\", \"IA\" -> \"Iowa\")\nval aNewMap = myMap - \"MN\"\n\naNewMap.equals(myMap) should be(__)","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan14","tag":"koan-task","data":{"description":"Map equivalency is independent of order","code":"val myMap1 = Map(\"MI\" -> \"Michigan\", \"OH\" -> \"Ohio\", \"WI\" -> \"Wisconsin\", \"IA\" -> \"Iowa\")\nval myMap2 = Map(\"WI\" -> \"Wisconsin\", \"MI\" -> \"Michigan\", \"IA\" -> \"Iowa\", \"OH\" -> \"Ohio\")\n\nmyMap1.equals(myMap2) should be(__)","mode":"scala","solutions":["true"]},"solution":"true"}]},{"id": 36, "title": " About Uniform  Access Principle", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Can access age as parameterless method","code":"val me = new CalculatesAgeUsingMethod(2010, 2003)\nme.age should be(__)","mode":"scala","solutions":["7"]},"solution":"7"},{"id":"koan2","tag":"koan-task","data":{"description":"Can access age as property","code":"val me = new CalculatesAgeUsingProperty(2010, 2003)\nme.age should be(__)","mode":"scala","solutions":["7"]},"solution":"7"},{"id":"koan3","tag":"koan-task","data":{"description":"Cannot add parameter to Method invocation","code":"val me = new CalculatesAgeUsingMethod(2010, 2003)\n// uncomment following line to see what happens if you try to access parameterless method with parens\n// me.age() should be (__) // Int does not take parameters","mode":"scala","solutions":["7"]},"solution":"7"},{"id":"koan4","tag":"koan-task","data":{"description":"What happens when I update current year using property","code":"val me = new CalculatesAgeUsingProperty(2010, 2003)\n\nme.currentYear = 2011\nme.age should be(__) // me.age is computed at construction time so same as before","mode":"scala","solutions":["7"]},"solution":"7"},{"id":"koan5","tag":"koan-task","data":{"description":"What happens when I update current year using method","code":"val me = new CalculatesAgeUsingMethod(2010, 2003)\n\n\nme.currentYear = 2011\nme.age should be(__) // here age is a method so called each time and take the update of var into account","mode":"scala","solutions":["8"]},"solution":"8"}]},{"id": 37, "title": "About Formatting", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"String can be placed in format","code":"val s = \"Hello World\"\n\"Application %s\".format(s) should be (__)","mode":"scala","solutions":["\"Application Hello World\""]},"solution":"\"Application Hello World\""},{"id":"koan2","tag":"koan-task","data":{"description":"Character Literals can be an a single character","code":"val a = 'a'\nval b = 'B'\n\n//format(a) is a string format, meaning the \"%c\".format(x)\n//will return the string representation of the char.\n\n\"%c\".format(a) should be(__)\n\"%c\".format(b) should be(__)","mode":"scala","solutions":["\"a\"","\"B\""]},"solution":"\"a\",\"B\""},{"id":"koan3","tag":"koan-task","data":{"description":"Character Literals can be an escape sequence, including octal or hexidecimal","code":"val c = '\\u0061' //unicode for a\nval d = '\\141' //octal for a\nval e = '\\\"'\nval f = '\\\\'\n\n\n\"%c\".format(c) should be(__)\n\"%c\".format(d) should be(__)\n\"%c\".format(e) should be(__)\n\"%c\".format(f) should be(__)","mode":"scala","solutions":["\"a\"","\"a\"","\"\\\"\"","\"\\\\\""]},"solution":"\"a\",\"a\",\"\\\"\",\"\\\\\""},{"id":"koan4","tag":"koan-task","data":{"description":"Formatting can also include numbers","code":"val j = 190\n\"%d bottles of beer on the wall\" format j - 100 should be (__)","mode":"scala","solutions":["\"90 bottles of beer on the wall\""]},"solution":"\"90 bottles of beer on the wall\""},{"id":"koan5","tag":"koan-task","data":{"description":"Formatting can be used for any number of items, like a string and a number","code":"val j = 190\nval k = \"vodka\"\n\n\"%d bottles of %s on the wall\".format(j - 100, k) should be (__)","mode":"scala","solutions":["\"90 bottles of vodka on the wall\""]},"solution":"\"90 bottles of vodka on the wall\""}]},{"id": 38, "title": "About Iterables", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Iterable is a trait that has the ability to return an iterator of itself.\n Some known iterators are Sets, Lists, Vectors, Stacks, and Streams. Iterator has two\n important methods:  `hasNext`, which answers whether the iterator has another element\n available. `next` which will return the next element in the iterator.","code":"val list = List(3, 5, 9, 11, 15, 19, 21)\nval it = list.iterator\nif (it.hasNext) {\n  it.next should be(__)\n}","mode":"scala","solutions":["3"]},"solution":"3"},{"id":"koan2","tag":"koan-task","data":{"description":"`grouped` will return an fixed sized Iterable chucks of an Iterable","code":"val list = List(3, 5, 9, 11, 15, 19, 21, 24, 32)\nval it = list grouped 3\nit.next() should be(__)\nit.next() should be(__)\nit.next() should be(__)","mode":"scala","solutions":["List(3, 5, 9)","List(11, 15, 19)","List(21, 24, 32)"]},"solution":"List(3, 5, 9),List(11, 15, 19),List(21, 24, 32)"},{"id":"koan3","tag":"koan-task","data":{"description":"`sliding` will return an Iterable that shows a sliding window of an Iterable.","code":"val list = List(3, 5, 9, 11, 15, 19, 21, 24, 32)\nval it = list sliding 3\nit.next() should be(__)\nit.next() should be(__)\nit.next() should be(__)","mode":"scala","solutions":["List(3, 5, 9)","List(5, 9, 11)","List(9, 11, 15)"]},"solution":"List(3, 5, 9),List(5, 9, 11),List(9, 11, 15)"},{"id":"koan4","tag":"koan-task","data":{"description":"`sliding` can take the size of the window as well the size of the step during each\n iteration","code":"val list = List(3, 5, 9, 11, 15, 19, 21, 24, 32)\nval it = list sliding(3, 3)\nit.next() should be(__)\nit.next() should be(__)\nit.next() should be(__)","mode":"scala","solutions":["List(3, 5, 9)","List(11, 15, 19)","List(21, 24, 32)"]},"solution":"List(3, 5, 9),List(11, 15, 19),List(21, 24, 32)"},{"id":"koan5","tag":"koan-task","data":{"description":"`takeRight` is the opposite of 'take' in Traversable.  It retrieves the last elements\n of an Iterable. ","code":"val list = List(3, 5, 9, 11, 15, 19, 21, 24, 32)\n(list takeRight 3) should be(__)","mode":"scala","solutions":["List(21, 24, 32)"]},"solution":"List(21, 24, 32)"},{"id":"koan6","tag":"koan-task","data":{"description":"`dropRight` will drop the number of elements from the right. ","code":"val list = List(3, 5, 9, 11, 15, 19, 21, 24, 32)\n(list dropRight 3) should be(__)","mode":"scala","solutions":["List(3, 5, 9, 11, 15, 19)"]},"solution":"List(3, 5, 9, 11, 15, 19)"},{"id":"koan7","tag":"koan-task","data":{"description":"`zip` will stitch two iterables into an iterable of pairs of corresponding elements\n  from both iterables. e.g. Iterable(x1, x2, x3) zip Iterable(y1, y2, y3) will\n  return ((x1,y1), (x2, y2), (x3, y3))","code":"val xs = List(3, 5, 9)\nval ys = List(\"Bob\", \"Ann\", \"Stella\")\n(xs zip ys) should be(__)","mode":"scala","solutions":["List((3, \"Bob\"), (5, \"Ann\"), (9, \"Stella\"))"]},"solution":"List((3, \"Bob\"), (5, \"Ann\"), (9, \"Stella\"))"},{"id":"koan8","tag":"koan-task","data":{"description":"if two Iterables aren't the same size, then `zip` will only zip what can only be paired.\n  e.g. Iterable(x1, x2, x3) zip Iterable(y1, y2) will\n  return ((x1,y1), (x2, y2))","code":"val xs = List(3, 5, 9)\nval ys = List(\"Bob\", \"Ann\")\n(xs zip ys) should be(__)","mode":"scala","solutions":["List((3, \"Bob\"), (5, \"Ann\"))"]},"solution":"List((3, \"Bob\"), (5, \"Ann\"))"},{"id":"koan9","tag":"koan-task","data":{"description":"if two Iterables aren't the same size, then `zipAll` can provide filters for what it couldn't\n  find a complement for. e.g. Iterable(x1, x2, x3) zipAll (Iterable(y1, y2), x, y) will\n  return ((x1,y1), (x2, y2, y))","code":"val xs = List(3, 5, 9)\nval ys = List(\"Bob\", \"Ann\")\n(xs zipAll(ys, -1, \"?\")) should be(__)","mode":"scala","solutions":["List((3, \"Bob\"), (5, \"Ann\"), (9, \"?\"))"]},"solution":"List((3, \"Bob\"), (5, \"Ann\"), (9, \"?\"))"},{"id":"koan10","tag":"koan-task","data":{"description":"`zipWithIndex` will zip an Iterable with it's integer index","code":"val xs = List(\"Manny\", \"Moe\", \"Jack\")\nxs.zipWithIndex should be(__)","mode":"scala","solutions":["List((\"Manny\", 0), (\"Moe\", 1), (\"Jack\", 2))"]},"solution":"List((\"Manny\", 0), (\"Moe\", 1), (\"Jack\", 2))"},{"id":"koan11","tag":"koan-task","data":{"description":"`sameElements` will return true if the two iterables have the same number of elements","code":"val xs = List(\"Manny\", \"Moe\", \"Jack\")\nval ys = List(\"Manny\", \"Moe\", \"Jack\")\n(xs sameElements ys) should be(__)\n\nval xs1 = Set(3, 2, 1, 4, 5, 6, 7)\nval ys1 = Set(7, 2, 1, 4, 5, 6, 3)\n(xs1 sameElements ys1) should be(__)","mode":"scala","solutions":["true","true"]},"solution":"true,true"}]},{"id": 39, "title": " About  Val  And  Var", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"vars may be reassigned","code":"var a = 5\na should be(__)\n\na = 7\na should be(__)","mode":"scala","solutions":["5","7?"]},"solution":"5,7?"},{"id":"koan2","tag":"koan-task","data":{"description":"vals may not be reassigned","code":"val a = 5\na should be(__)\n\n// What happens if you uncomment these lines? compilation problem as a is immutable (reassignment to val)\n// a = 7\n// a should be (__)","mode":"scala","solutions":["5?","7"]},"solution":"5?,7"}]},{"id": 40, "title": "About  Mutable  Maps", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Mutable maps can be created easily","code":"val myMap = mutable.Map(\"MI\" -> \"Michigan\", \"OH\" -> \"Ohio\", \"WI\" -> \"Wisconsin\", \"IA\" -> \"Iowa\")\nmyMap.size should be(__)\nmyMap += \"OR\" -> \"Oregon\"\nmyMap contains \"OR\" should be(__)","mode":"scala","solutions":["4","true"]},"solution":"4,true"},{"id":"koan2","tag":"koan-task","data":{"description":"Mutable maps can have elements removed","code":"val myMap = mutable.Map(\"MI\" -> \"Michigan\", \"OH\" -> \"Ohio\", \"WI\" -> \"Wisconsin\", \"IA\" -> \"Iowa\")\nmyMap -= \"OH\"\nmyMap contains \"OH\" should be(__)","mode":"scala","solutions":["false"]},"solution":"false"},{"id":"koan3","tag":"koan-task","data":{"description":"Mutable maps can have tuples of elements removed","code":"val myMap = mutable.Map(\"MI\" -> \"Michigan\", \"OH\" -> \"Ohio\", \"WI\" -> \"Wisconsin\", \"IA\" -> \"Iowa\")\nmyMap -= (\"IA\", \"OH\")\nmyMap contains \"OH\" should be(__)\nmyMap.size should be(__)","mode":"scala","solutions":["false","2"]},"solution":"false,2"},{"id":"koan4","tag":"koan-task","data":{"description":"Mutable maps can have tuples of elements added","code":"val myMap = mutable.Map(\"MI\" -> \"Michigan\", \"WI\" -> \"Wisconsin\")\nmyMap += (\"IA\" -> \"Iowa\", \"OH\" -> \"Ohio\")\nmyMap contains \"OH\" should be(__)\nmyMap.size should be(__)","mode":"scala","solutions":["true","4"]},"solution":"true,4"},{"id":"koan5","tag":"koan-task","data":{"description":"Mutable maps can have Lists of elements added","code":"val myMap = mutable.Map(\"MI\" -> \"Michigan\", \"WI\" -> \"Wisconsin\")\nmyMap ++= List(\"IA\" -> \"Iowa\", \"OH\" -> \"Ohio\")\nmyMap contains \"OH\" should be(__)\nmyMap.size should be(__)","mode":"scala","solutions":["true","4"]},"solution":"true,4"},{"id":"koan6","tag":"koan-task","data":{"description":"Mutable maps can have Lists of elements removed","code":"val myMap = mutable.Map(\"MI\" -> \"Michigan\", \"OH\" -> \"Ohio\", \"WI\" -> \"Wisconsin\", \"IA\" -> \"Iowa\")\nmyMap --= List(\"IA\", \"OH\")\nmyMap contains \"OH\" should be(__)\nmyMap.size should be(__)","mode":"scala","solutions":["false","2"]},"solution":"false,2"},{"id":"koan7","tag":"koan-task","data":{"description":"Mutable maps can be cleared","code":"val myMap = mutable.Map(\"MI\" -> \"Michigan\", \"OH\" -> \"Ohio\", \"WI\" -> \"Wisconsin\", \"IA\" -> \"Iowa\")\nmyMap.clear() // Convention is to use parens if possible when method called changes state\nmyMap contains \"OH\" should be(__)\nmyMap.size should be(__)","mode":"scala","solutions":["false","0"]},"solution":"false,0"}]},{"id": 41, "title": "About Partial Functions", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"A partial function is a trait that when\n implemented can be used as building blocks to determine\n a solution.  The trait PartialFunction requires that\n the method isDefinedAt and apply be implemented.","code":"val doubleEvens: PartialFunction[Int, Int] = new PartialFunction[Int, Int] {\n  //States that this partial function will take on the task\n  def isDefinedAt(x: Int) = x % 2 == 0\n\n  //What we do if this does partial function matches\n  def apply(v1: Int) = v1 * 2\n}\n\nval tripleOdds: PartialFunction[Int, Int] = new PartialFunction[Int, Int] {\n  def isDefinedAt(x: Int) = x % 2 != 0\n\n  def apply(v1: Int) = v1 * 3\n}\n\nval whatToDo = doubleEvens orElse tripleOdds //Here we chain the partial functions together\n\nwhatToDo(3) should be(__)\nwhatToDo(4) should be(__)","mode":"scala","solutions":["9","8"]},"solution":"9,8"},{"id":"koan2","tag":"koan-task","data":{"description":"Case statements are a quick way to create partial functions. When you create a case\n statement, the apply and isDefinedAt is created for you.","code":"//The case statements are called case statements with guards\nval doubleEvens: PartialFunction[Int, Int] = {\n  case x: Int if (x % 2) == 0 => x * 2\n}\nval tripleOdds: PartialFunction[Int, Int] = {\n  case x: Int if (x % 2) != 0 => x * 3\n}\n\nval whatToDo = doubleEvens orElse tripleOdds //Here we chain the partial functions together\nwhatToDo(3) should be(__)\nwhatToDo(4) should be(__)","mode":"scala","solutions":["9","8"]},"solution":"9,8"},{"id":"koan3","tag":"koan-task","data":{"description":"The result of partial functions can have an \\'andThen\\' function added to the end\n of the chain","code":"//These are called case statements with guards\nval doubleEvens: PartialFunction[Int, Int] = {\n  case x: Int if (x % 2) == 0 => x * 2\n}\nval tripleOdds: PartialFunction[Int, Int] = {\n  case x: Int if (x % 2) != 0 => x * 3\n}\n\nval addFive = (x: Int) => x + 5\nval whatToDo = doubleEvens orElse tripleOdds andThen addFive //Here we chain the partial functions together\nwhatToDo(3) should be(__)\nwhatToDo(4) should be(__)","mode":"scala","solutions":["14","13"]},"solution":"14,13"},{"id":"koan4","tag":"koan-task","data":{"description":"The result of partial functions can have an \\'andThen\\' function added to the end\n of the chain used to continue onto another chain of logic","code":"val doubleEvens: PartialFunction[Int, Int] = {\n  case x: Int if (x % 2) == 0 => x * 2\n}\nval tripleOdds: PartialFunction[Int, Int] = {\n  case x: Int if (x % 2) != 0 => x * 3\n}\n\nval printEven: PartialFunction[Int, String] = {\n  case x: Int if (x % 2) == 0 => \"Even\"\n}\nval printOdd: PartialFunction[Int, String] = {\n  case x: Int if (x % 2) != 0 => \"Odd\"\n}\n\nval whatToDo = doubleEvens orElse tripleOdds andThen (printEven orElse printOdd)\n\nwhatToDo(3) should be(__)\nwhatToDo(4) should be(__)","mode":"scala","solutions":["\"Odd\"","\"Even\""]},"solution":"\"Odd\",\"Even\""}]},{"id": 42, "title": "About Empty Values", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"None equals None","code":"assert(None === __)","mode":"scala","solutions":["None"]},"solution":"None"},{"id":"koan2","tag":"koan-task","data":{"description":"None should be identical to None","code":"val a = None\nval b = None\nassert(a eq __)","mode":"scala","solutions":["b"]},"solution":"b"},{"id":"koan3","tag":"koan-task","data":{"description":"None can be converted to a String","code":"assert(None.toString === __)","mode":"scala","solutions":["\"None\""]},"solution":"\"None\""},{"id":"koan4","tag":"koan-task","data":{"description":"An empty list can be represented by another nothing value: Nil","code":"assert(List() === __)","mode":"scala","solutions":["Nil"]},"solution":"Nil"},{"id":"koan5","tag":"koan-task","data":{"description":"None can be converted to an empty list","code":"val a = None\nassert(a.toList === __)","mode":"scala","solutions":["Nil"]},"solution":"Nil"},{"id":"koan6","tag":"koan-task","data":{"description":"None is considered empty","code":"assert(None.isEmpty === __)","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan7","tag":"koan-task","data":{"description":"None can be cast Any, AnyRef or AnyVal","code":"assert(None.asInstanceOf[Any] === __)\nassert(None.asInstanceOf[AnyRef] === __)\nassert(None.asInstanceOf[AnyVal] === __)","mode":"scala","solutions":["None","None","None"]},"solution":"None,None,None"},{"id":"koan8","tag":"koan-task","data":{"description":"None cannot be cast to all types of objects","code":"intercept[ClassCastException] {\n  // put the exception you expect to see in place of the blank\n  assert(None.asInstanceOf[String] === __)\n}","mode":"scala","solutions":["false"]},"solution":"false"},{"id":"koan9","tag":"koan-task","data":{"description":"None can be used with Option instead of null references","code":"val optional: Option[String] = None\nassert(optional.isEmpty === __)\nassert(optional === __)","mode":"scala","solutions":["true","None"]},"solution":"true,None"},{"id":"koan10","tag":"koan-task","data":{"description":"Some is the opposite of None for Option types","code":"val optional: Option[String] = Some(\"Some Value\")\nassert((optional == None) === __, \"Some(value) should not equal None\")\nassert(optional.isEmpty === __, \"Some(value) should not be empty\")","mode":"scala","solutions":["false","false"]},"solution":"false,false"},{"id":"koan11","tag":"koan-task","data":{"description":"Option.getOrElse can be used to provide a default in the case of None","code":"val optional: Option[String] = Some(\"Some Value\")\nval optional2: Option[String] = None\nassert(optional.getOrElse(\"No Value\") === __, \"Should return the value in the option\")\nassert(optional2.getOrElse(\"No Value\") === __, \"Should return the specified default value\")","mode":"scala","solutions":["\"Some Value\"","\"No Value\""]},"solution":"\"Some Value\",\"No Value\""}]},{"id": 43, "title": "About Literal Strings", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Character Literals are quoted with single quotes","code":"val a = 'a'\nval b = 'B'\n\na.toString should be(__)\nb.toString should be(__)","mode":"scala","solutions":["\"a\"","\"B\""]},"solution":"\"a\",\"B\""},{"id":"koan2","tag":"koan-task","data":{"description":"Character Literals can use hexadecimal Unicode","code":"val c = '\\u0061' //unicode for a\n\nc.toString should be(__)","mode":"scala","solutions":["\"a\""]},"solution":"\"a\""},{"id":"koan3","tag":"koan-task","data":{"description":"Character Literals can use octal as well","code":"val d = '\\141' //octal for a\n\nd.toString should be(__)","mode":"scala","solutions":["\"a\""]},"solution":"\"a\""},{"id":"koan4","tag":"koan-task","data":{"description":"Character Literals can use escape sequences","code":"val e = '\\\"'\nval f = '\\\\'\n\ne.toString should be(__)\nf.toString should be(__)","mode":"scala","solutions":["\"\\\"\"","\"\\\\\""]},"solution":"\"\\\"\",\"\\\\\""},{"id":"koan5","tag":"koan-task","data":{"description":"One-Line String Literals are surrounded by quotation marks.","code":"val a = \"To be or not to be\"\na should be(__)","mode":"scala","solutions":["\"To be or not to be\""]},"solution":"\"To be or not to be\""},{"id":"koan6","tag":"koan-task","data":{"description":"String Literals can contain escape sequences.","code":"val a = \"An \\141pple \\141 d\\141y keeps the doctor \\141w\\141y\"\na should be(__)","mode":"scala","solutions":["\"An apple a day keeps the doctor away\""]},"solution":"\"An apple a day keeps the doctor away\""},{"id":"koan7","tag":"koan-task","data":{"description":"Multiline String literals\n\tare surrounded\n\tby three quotation marks","code":"val a = \"\"\"An apple a day\nkeeps the doctor away\"\"\"\na.split('\\n').size should be(__).size determines the number of lines","mode":"scala","solutions":["2) //a.split('\\n'"]},"solution":"2) //a.split('\\n'"},{"id":"koan8","tag":"koan-task","data":{"description":"Use stripMargin to prettify multi-line strings","code":"/*\n\t  * Multiline String literals can use | to specify the starting position\n\t  * of subsequent lines, then use stripMargin to remove the surplus indentation.\n\t  */\n\n val a = \"\"\"An apple a day\n            |keeps the doctor away\"\"\"\n a.stripMargin.split('\\n')(1).charAt(0) should be(__)\n\n/*\n\t  * a.stripMargin.split('\\n')(1).charAt(0)\n * gets the first character of the second line\n\t  */","mode":"scala","solutions":["'k'"]},"solution":"'k'"}]},{"id": 44, "title": "About Path Dependent Types", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"When a class is instantiated inside of another object, it belongs to the object.  This is a path\n dependent type. Once established, it cannot be placed inside of another object","code":"val b1 = Board(20, 20)\nval b2 = Board(30, 30)\nval c1 = b1.Coordinate(15, 15)\nval c2 = b2.Coordinate(25, 25)\n\nb1.occupied += c1\nb2.occupied += c2\n// Next line doesn't compile, uncomment to try, then comment and answer the koan next\n//b1.occupied += c2\n\nc1.x should be (__)","mode":"scala","solutions":["15"]},"solution":"15"}]},{"id": 45, "title": "About Extractors", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"When you create a case class, it automatically can be used with pattern matching since it has an extractor","code":"case class Employee(firstName:String, lastName:String)\n\nval rob = new Employee(\"Robin\", \"Williams\")\nval result = rob match {\n  case Employee(\"Robin\", _) => \"Where's Batman?\"\n  case _ => \"No Batman Joke For You\"\n}\n\nresult should be (__)","mode":"scala","solutions":["\"Where's Batman?\""]},"solution":"\"Where's Batman?\""},{"id":"koan2","tag":"koan-task","data":{"description":"What's an extractor? In Scala it's a method in any `object` called `unapply`, and that method\n is used to disassemble the object given by returning a tuple wrapped in an option. Extractors can be used\n to assign values.","code":"class Car(val make:String, val model:String, val year:Short, val topSpeed:Short)\n\nobject ChopShop {\n   def unapply(x:Car) = Some(x.make, x.model, x.year, x.topSpeed)\n}\n\nval ChopShop(a, b, c, d) = new Car(\"Chevy\", \"Camaro\", 1978, 120)\n\na should be (__)\nb should be (__)\nc should be (__)\nd should be (__)","mode":"scala","solutions":["\"Chevy\"","\"Camaro\"","1978","120"]},"solution":"\"Chevy\",\"Camaro\",1978,120"},{"id":"koan3","tag":"koan-task","data":{"description":"Of course an extractor can be used in pattern matching...","code":"class Car(val make:String, val model:String, val year:Short, val topSpeed:Short)\n\nobject ChopShop {\n  def unapply(x:Car) = Some(x.make, x.model, x.year, x.topSpeed)\n}\n\nval x = new Car(\"Chevy\", \"Camaro\", 1978, 120) match {\n  case ChopShop(s,t,u,v) => (s,t)\n//  case _                 => (\"Ford\", \"Edsel\") // matching unreachable here\n}\n\nx._1 should be (__)\nx._2 should be (__)","mode":"scala","solutions":["\"Chevy\"","\"Camaro\""]},"solution":"\"Chevy\",\"Camaro\""},{"id":"koan4","tag":"koan-task","data":{"description":"Since we aren't really using c and d in the previous pattern matching with can replace them with _.","code":"class Car(val make:String, val model:String, val year:Short, val topSpeed:Short)\n\nobject ChopShop {\n  def unapply(x:Car) = Some(x.make, x.model, x.year, x.topSpeed)\n}\n\nval x = new Car(\"Chevy\", \"Camaro\", 1978, 120) match {\n  case ChopShop(s,t,_,_) => (s,t)\n//  case _                 => (\"Ford\", \"Edsel\") // matching unreachable here\n}\n\nx._1 should be (__)\nx._2 should be (__)","mode":"scala","solutions":["\"Chevy\"","\"Camaro\""]},"solution":"\"Chevy\",\"Camaro\""},{"id":"koan5","tag":"koan-task","data":{"description":"As long as the method signatures aren't the same, you can have an many unapply methods as you want","code":"class Car(val make:String, val model:String, val year:Short, val topSpeed:Short)\nclass Employee(val firstName:String, val middleName: Option[String], val lastName: String)\n\nobject Tokenizer {\n  def unapply(x:Car) = Some(x.make, x.model, x.year, x.topSpeed)\n  def unapply(x:Employee) = Some(x.firstName, x.lastName)\n}\n\nval result = new Employee(\"Kurt\", None, \"Vonnegut\") match {\n  case Tokenizer(c,d) => \"c: %s, d: %s\".format(c,d)\n//  case _              => \"Not found\" // case unreachable\n}\n\nresult should be (__)","mode":"scala","solutions":["\"c: Kurt, d: Vonnegut\""]},"solution":"\"c: Kurt, d: Vonnegut\""},{"id":"koan6","tag":"koan-task","data":{"description":"An extractor can be any stable object, including instantiated classes with an unapply method.","code":"class Car(val make:String, val model:String, val year:Short, val topSpeed:Short)   {\n  def unapply(x:Car) = Some(x.make, x.model)\n}\n\nval camaro = new Car(\"Chevy\", \"Camaro\", 1978, 122)\n\nval result = camaro match {\n  case camaro(make, model) => \"make: %s, model: %s\".format(make, model)\n//  case _                   => \"unknown\" // case unreachable\n}\n\nresult should be (__)","mode":"scala","solutions":["\"make: Chevy, model: Camaro\""]},"solution":"\"make: Chevy, model: Camaro\""},{"id":"koan7","tag":"koan-task","data":{"description":"What is typical is to create a custom extractor in the companion object of the class.\n In this koan, we use it as an assignment","code":"class Employee(val firstName:String,\n               val middleName:Option[String],\n               val lastName:String)\n\nobject Employee {\n  //factory methods, extractors, apply\n  //Extractor: Create tokens that represent your object\n  def unapply(x:Employee) =\n    Some(x.lastName, x.middleName, x.firstName)\n}\n\nval singri = new Employee(\"Singri\", None, \"Keerthi\")\n\nval Employee(a,b,c) = singri\na should be (__)\nb should be (__)\nc should be (__)","mode":"scala","solutions":["\"Keerthi\"","None","\"Singri\""]},"solution":"\"Keerthi\",None,\"Singri\""},{"id":"koan8","tag":"koan-task","data":{"description":"In this koan we use the unapply for pattern matching employee objects","code":"class Employee(val firstName:String,\n               val middleName:Option[String],\n               val lastName:String)\n\nobject Employee {\n  //factory methods, extractors, apply\n  //Extractor: Create tokens that represent your object\n  def unapply(x:Employee) =\n    Some(x.lastName, x.middleName, x.firstName)\n}\n\nval singri = new Employee(\"Singri\", None, \"Keerthi\")\n\nsingri match {\n  case Employee(\"Singri\", None, x)    => \"Yay, Singri %s! with no middle name!\".format(x)\n  case Employee(\"Singri\", Some(x), _) => \"Yay, Singri with a middle name of %s\".format(x)\n  case _                              => \"I don't care, going on break\"\n}\nsingri should be (__)","mode":"scala","solutions":["\"I don't care, going on break\""]},"solution":"\"I don't care, going on break\""}]},{"id": 46, "title": "About For Expressions", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"For loops can be simple","code":"val someNumbers = Range(0, 10) // non-inclusive on the upper bound\nvar sum = 0\nfor (i <- someNumbers)\n  sum += i\n\nsum should equal(__)","mode":"scala","solutions":["45"]},"solution":"45"},{"id":"koan2","tag":"koan-task","data":{"description":"For loops can contain additional logic","code":"val someNumbers = Range(0, 10)\nvar sum = 0\n// sum only the even numbers\nfor (i <- someNumbers)\n  if (i % 2 == 0) sum += i\n\nsum should equal(__)","mode":"scala","solutions":["20"]},"solution":"20"},{"id":"koan3","tag":"koan-task","data":{"description":"For expressions can nest, with later generators varying more rapidly than earlier ones","code":"val xValues = Range(1, 5)\nval yValues = Range(1, 3)\nval coordinates = for {\n  x <- xValues\n  y <- yValues\n}\nyield (x, y)\ncoordinates(4) should be(__)","mode":"scala","solutions":["(3, 1)"]},"solution":"(3, 1)"}]},{"id": 47, "title": "About Methods", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"In scala, methods can be placed inside in methods, this comes useful for\n recursion where accumulator helper methods can be placed inside the outer method","code":"def factorial(i: Int): Int = {\n  def fact(i: Int, accumulator: Int): Int = {\n    if (i <= 1)\n      accumulator\n    else\n      fact(i - 1, i * accumulator)\n  }\n  fact(i, 1)\n}\n\nfactorial(3) should be (__)","mode":"scala","solutions":["6"]},"solution":"6"},{"id":"koan2","tag":"koan-task","data":{"description":"If a method does not of have equal it is considered `Unit` which is analogous to `void` in Java","code":"def foo(x:Int) {\n  (x + 4)\n}\n\nfoo(5) should be (__)","mode":"scala","solutions":["()"]},"solution":"()"},{"id":"koan3","tag":"koan-task","data":{"description":"If you want to have an = on the method you can make the return type `Unit`,\n this also analogous to `void","code":"def foo(x:Int):Unit = {\n  (x + 4)\n}\n\nfoo(3) should be (__)","mode":"scala","solutions":["()"]},"solution":"()"},{"id":"koan4","tag":"koan-task","data":{"description":"Once you have an =, it is understood that there will be a return type and can be inferred","code":"def foo(x:Int) = 3 + 4\nfoo(3).isInstanceOf[Int] should be (__)","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan5","tag":"koan-task","data":{"description":"Of course if you wish to be explicit about the return type, you can attach it at the end of the method","code":"def foo(x:Int):Int = 3 + 4\nfoo(3).isInstanceOf[Int] should be (__)","mode":"scala","solutions":["true"]},"solution":"true"},{"id":"koan6","tag":"koan-task","data":{"description":"As an important concept in function programming and in Scala, a method is also a function","code":"def foo(x:Int) = x * 2\nval result = List(1,2,3).map(foo) //map performs a function on each element\nresult should be (__)","mode":"scala","solutions":["List(2,4,6)"]},"solution":"List(2,4,6)"}]},{"id": 48, "title": "About Pattern Matching", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Pattern matching returns something","code":"val stuff = \"blue\"\n\nval myStuff = stuff match {\n  case \"red\" => println(\"RED\"); 1\n  case \"blue\" => println(\"BLUE\"); 2\n  case \"green\" => println(\"GREEN\"); 3\n  case _ => println(stuff); 0 //case _ will trigger if all other cases fail.\n}\n\nmyStuff should be(__)","mode":"scala","solutions":["2"]},"solution":"2"},{"id":"koan2","tag":"koan-task","data":{"description":"Pattern matching can return complex somethings","code":"val stuff = \"blue\"\n\nval myStuff = stuff match {\n  case \"red\" => (255, 0, 0)\n  case \"green\" => (0, 255, 0)\n  case \"blue\" => (0, 0, 255)\n  case _ => println(stuff); 0\n}\n\nmyStuff should be(__)","mode":"scala","solutions":["0, 0, 255"]},"solution":"0, 0, 255"},{"id":"koan3","tag":"koan-task","data":{"description":"Pattern matching can match complex expressions","code":"def goldilocks(expr: Any) = expr match {\n  case (\"porridge\", \"Papa\") => \"Papa eating porridge\"\n  case (\"porridge\", \"Mama\") => \"Mama eating porridge\"\n  case (\"porridge\", \"Baby\") => \"Baby eating porridge\"\n  case _ => \"what?\"\n}\n\ngoldilocks((\"porridge\", \"Mama\")) should be(__)","mode":"scala","solutions":["\"Mama eating porridge\""]},"solution":"\"Mama eating porridge\""},{"id":"koan4","tag":"koan-task","data":{"description":"Pattern matching can wildcard parts of expressions","code":"def goldilocks(expr: Any) = expr match {\n  case (\"porridge\", _) => \"eating\"\n  case (\"chair\", \"Mama\") => \"sitting\"\n  case (\"bed\", \"Baby\") => \"sleeping\"\n  case _ => \"what?\"\n}\n\ngoldilocks((\"porridge\", \"Papa\")) should be(__)\ngoldilocks((\"chair\", \"Mama\")) should be(__)","mode":"scala","solutions":["\"eating\"","\"sitting\""]},"solution":"\"eating\",\"sitting\""},{"id":"koan5","tag":"koan-task","data":{"description":"Pattern matching can substitute parts of expressions","code":"def goldilocks(expr: Any) = expr match {\n  case (\"porridge\", bear) => bear + \" said someone's been eating my porridge\"\n  case (\"chair\", bear) => bear + \" said someone's been sitting in my chair\"\n  case (\"bed\", bear) => bear + \" said someone's been sleeping in my bed\"\n  case _ => \"what?\"\n}\n\ngoldilocks((\"porridge\", \"Papa\")) should be(__)\ngoldilocks((\"chair\", \"Mama\")) should be(__)","mode":"scala","solutions":["\"Papa said someone's been eating my porridge\"","\"Mama said someone's been sitting in my chair\""]},"solution":"\"Papa said someone's been eating my porridge\",\"Mama said someone's been sitting in my chair\""},{"id":"koan6","tag":"koan-task","data":{"description":"Pattern matching can be done on regular expression groups","code":"val EatingRegularExpression = \"\"\"Eating Alert: bear=([^,]+),\\s+source=(.+)\"\"\".r     //.r turns a String to a regular expression\nval SittingRegularExpression = \"\"\"Sitting Alert: bear=([^,]+),\\s+source=(.+)\"\"\".r\nval SleepingRegularExpression = \"\"\"Sleeping Alert: bear=([^,]+),\\s+source=(.+)\"\"\".r\n\ndef goldilocks(expr: String) = expr match {\n  case (EatingRegularExpression(bear, source)) => \"%s said someone's been eating my %s\".format(bear, source)\n  case (SittingRegularExpression(bear, source)) => \"%s said someone's been sitting on my %s\".format(bear, source)\n  case (SleepingRegularExpression(bear, source)) => \"%s said someone's been sleeping in my %s\".format(bear, source)\n  case _ => \"what?\"\n}\n\ngoldilocks(\"Eating Alert: bear=Papa, source=porridge\") should be(__)\ngoldilocks(\"Sitting Alert: bear=Mama, source=chair\") should be(__)","mode":"scala","solutions":["\"Papa said someone's been eating my porridge\"","\"Mama said someone's been sitting on my chair\""]},"solution":"\"Papa said someone's been eating my porridge\",\"Mama said someone's been sitting on my chair\""},{"id":"koan7","tag":"koan-task","data":{"description":"A backquote can be used to refer to a stable variable in scope to create a case statement.\n This prevents what is called \\'Variable Shadowing\\'","code":"val foodItem = \"porridge\"\n\ndef goldilocks(expr: Any) = expr match {\n  case (`foodItem`, _) => \"eating\"\n  case (\"chair\", \"Mama\") => \"sitting\"\n  case (\"bed\", \"Baby\") => \"sleeping\"\n  case _ => \"what?\"\n}\n\ngoldilocks((\"porridge\", \"Papa\")) should be(__)\ngoldilocks((\"chair\", \"Mama\")) should be(__)\ngoldilocks((\"porridge\", \"Cousin\")) should be(__)\ngoldilocks((\"beer\", \"Cousin\")) should be(__)","mode":"scala","solutions":["\"eating\"","\"sitting\"","\"eating\"","\"what?\""]},"solution":"\"eating\",\"sitting\",\"eating\",\"what?\""},{"id":"koan8","tag":"koan-task","data":{"description":"A backquote can be used to refer to a method parameter as a stable variable to create a case statement.","code":"def patternEquals(i: Int, j: Int) = j match {\n  case `i` => true\n  case _ => false\n}\npatternEquals(3, 3) should be(__)\npatternEquals(7, 9) should be(__)\npatternEquals(9, 9) should be(__)","mode":"scala","solutions":["true","false","true"]},"solution":"true,false,true"}]}]}""")
      val json: JsValue = Json.parse("""{"title": "Neuer Kurs 5","chapters": [{"id": 1, "title": "About Mutable Sets", "tasks": [{"id":"koan1","tag":"koan-task","data":{"description":"Mutable sets can be created easily","code":"val mySet = mutable.Set(\"Michigan\", \"Ohio\", \"Wisconsin\", \"Iowa\")\nmySet.size should be(__)\nmySet += \"Oregon\"\nmySet contains \"Oregon\" should be(__)","mode":"scala","solutions":["4","true"]},"solution":"4,true"},{"id":"koan2","tag":"koan-task","data":{"description":"Mutable sets can have elements removed","code":"val mySet = mutable.Set(\"Michigan\", \"Ohio\", \"Wisconsin\", \"Iowa\")\nmySet -= \"Ohio\"\nmySet contains \"Ohio\" should be(__)","mode":"scala","solutions":["false"]},"solution":"false"},{"id":"koan3","tag":"koan-task","data":{"description":"Mutable sets can have tuples of elements removed","code":"val mySet = mutable.Set(\"Michigan\", \"Ohio\", \"Wisconsin\", \"Iowa\")\nmySet -= (\"Iowa\", \"Ohio\")\nmySet contains \"Ohio\" should be(__)\nmySet.size should be(__)","mode":"scala","solutions":["false","2"]},"solution":"false,2"},{"id":"koan4","tag":"koan-task","data":{"description":"Mutable sets can have tuples of elements added","code":"val mySet = mutable.Set(\"Michigan\", \"Wisconsin\")\nmySet += (\"Iowa\", \"Ohio\")\nmySet contains \"Ohio\" should be(__)\nmySet.size should be(__)","mode":"scala","solutions":["true","4"]},"solution":"true,4"},{"id":"koan5","tag":"koan-task","data":{"description":"Mutable sets can have Lists of elements added","code":"val mySet = mutable.Set(\"Michigan\", \"Wisconsin\")\nmySet ++= List(\"Iowa\", \"Ohio\")\nmySet contains \"Ohio\" should be(__)\nmySet.size should be(__)","mode":"scala","solutions":["true","4"]},"solution":"true,4"},{"id":"koan6","tag":"koan-task","data":{"description":"Mutable sets can have Lists of elements removed","code":"val mySet = mutable.Set(\"Michigan\", \"Ohio\", \"Wisconsin\", \"Iowa\")\nmySet --= List(\"Iowa\", \"Ohio\")\nmySet contains \"Ohio\" should be(__)\nmySet.size should be(__)","mode":"scala","solutions":["false","2"]},"solution":"false,2"},{"id":"koan7","tag":"koan-task","data":{"description":"Mutable sets can be cleared","code":"val mySet = mutable.Set(\"Michigan\", \"Ohio\", \"Wisconsin\", \"Iowa\")\nmySet.clear() // Convention is to use parens if possible when method called changes state\nmySet contains \"Ohio\" should be(__)\nmySet.size should be(__)","mode":"scala","solutions":["false","0"]},"solution":"false,0"}]}]}""")
      val request = FakeRequest(POST, "/api/courses")
        .withJsonBody(json)
        .withHeaders(("Authorization", auth))
      val result = route(request)

      status(result.get) must equalTo(CREATED)
      courseId = header("Location", result.get).get.replace("/api/courses/", "")
      header("Location", result.get).get must contain("/api/courses/")
    }
    "get Course" in new WithApplication {
      val request = FakeRequest(GET, "/api/courses/" + courseId)
        val result = route(request)

      var failed = 0
      for(_ <- 1 to loop) {
        val r = route(request)
        if (status(r.get) != OK) failed = failed + 1
      }

      failed shouldEqual(0)
      status(result.get) must equalTo(OK)
    }
    "get all Course" in new WithApplication {
      val request = FakeRequest(GET, "/api/courses/all")
      val result = route(request)

      var failed = 0
      for(_ <- 1 to loop) {
        val r = route(request)
        if (status(r.get) != OK) failed = failed + 1
      }

      failed shouldEqual(0)

      status(result.get) must equalTo(OK)
    }
    "update Course" in new WithApplication {
      val json: JsValue = Json.parse("""{"id": """ + courseId + """, "title": "Neuer Kurs 5","chapters": [{"id": 1,"title": "About Scala Lists","tasks": [{"id": "video1","tag": "video-task","data": {"description": "In diesem Kapitel sollend Listen in Scala näher erläutert werden\n Listen sind collections und können objekte speichern\n Listen sind prinzipiell immutable also unveränderbar\n Im folgenden Video werden Listen ausfürlich erläutert","url": "U23j6yH21W4"},"solution": "watched"},{"id": "koan1","tag": "koan-task","data": {"description": "Mit der Funktion <b>contains</b> kann geprüft werden ob eine Liste ein bestimmtes Element enthält.\n Mit der Funktion <b>map</b> können funktionen auf listen angewendet werden, die Ergebnisse werden in einer neuen Liste gespeichert.\n Versuch in dem folgenden <b>Koan</b> die richtigen Werte einzutragen","code": "val l = List(1, 2, 3, 4)\nval l2 = l.map { x => x + 1 }\nval l3 = l.map { x => x * x }\n\nl should be (__)\nl2 should be(__)\nl3 shouldBe __", "mode":"scala", "solutions": ["List(1, 2, 3, 4)","List(2, 3, 4, 5)","List(1, 4, 9, 16)"]},"solution": "List(1, 2, 3, 4),List(2, 3, 4, 5),List(1, 4, 9, 16)"},{"id": "koan2","tag": "koan-task","data": {"description": "Zu Listen können auch Werte hinzugefügt werden.<br>Dies kann mit <b>++</b> geschehen.","code": "val x = 1\nval y = 300\n//some\n//lonely\n//comment\n//to\n//add\n//lines\nval l = List(1, 3, 5)\nval l2 = l ++ List(6)\n    \nl2 shouldBe __", "mode":"scala", "solutions": ["List(1, 3, 5, 6)"]},"solution": "List(1, 3, 5, 6)"},{"id": "code1","tag": "code-task","data": {"description": "schreiben sie eine function reverse die eine umgekehrte liste zurück geben.\n Nutzen Sie nicht die bereits vorhandenen Möglichkeit\n <b>List.reverse</b>", "mode":"scala", "code": "def rvrs(l: List[Any]): List[Any] = {\n  //solve\n}"},"solution": "rvrs(List(1, 2, 3)) should be(List(3, 2, 1))"},{"id": "koan3","tag": "koan-task","data": {"description": "Java Koan", "mode":"java","code": "@RunWith(KoanRunner.class)\n  public class MyKoans {\n\t@Koan\n\tpublic void test() {\n\t\tint i= 10;\n\t\tint j = 5;\n\t\tint product = i * j;\n\n\t\tassertThat(product, is(__)\n\t}\n}","solutions": ["50"]},"solution": "50"}]}]}""")
      val request = FakeRequest(PUT, "/api/courses/" + courseId)
          .withJsonBody(json)
          .withHeaders(("Authorization", auth))
        val result = route(request)

      status(result.get) must equalTo(OK)
    }
    "delete Course" in new WithApplication {
      val request = FakeRequest(DELETE, "/api/courses/" + courseId)
          .withHeaders(("Authorization", auth))
        val result = route(request)

      status(result.get) must equalTo(OK)
    }
  }

  "Application User API" should {
    "create User" in new WithApplication {
      val json: JsValue = Json.parse("""{"username": "test@test.de", "authority": "student", "password": "test", "chapterSolutions": [], "subscriptions": []}""")
      val request = FakeRequest(POST, "/api/users")
          .withJsonBody(json)
          .withHeaders(("Authorization", auth))
        val result = route(request)

      status(result.get) must equalTo(CREATED)

      userId = header("Location", result.get).get.replace("/api/users/", "")
      header("Location", result.get).get must contain("/api/users/")
    }
    "get User" in new WithApplication {
      val request = FakeRequest(GET, "/api/users/" + userId)
          .withHeaders(("Authorization", auth))
        val result = route(request)

      status(result.get) must equalTo(OK)
    }
    "update User" in new WithApplication {
      val json: JsValue = Json.parse("""{"username": "test@test.de", "authority": "student", "password": "test", "chapterSolutions": [], "subscriptions": []}""")
        val request = FakeRequest(PUT, "/api/users/" + userId)
          .withJsonBody(json)
          .withHeaders(("Authorization", auth))
        val result = route(request)

      status(result.get) must equalTo(OK)
    }
    "delete User" in new WithApplication {
      val request = FakeRequest(DELETE, "/api/users/" + userId)
          .withHeaders(("Authorization", auth))
        val result = route(request)

      status(result.get) must equalTo(OK)
    }
    "get all Users" in new WithApplication {
      val request = FakeRequest(GET, "/api/users/all")
          .withHeaders(("Authorization", auth))
      val result = route(request)

      status(result.get) must equalTo(OK)
    }
  }
}